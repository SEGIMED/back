This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.dockerignore
.eslintrc.js
.gitignore
.prettierrc
DockerFile
nest-cli.json
package.json
prisma/schema.prisma
src/app.controller.spec.ts
src/app.controller.ts
src/app.module.ts
src/app.service.ts
src/auth/controllers/roles.controller.ts
src/auth/decorators/require-permission.decorator.ts
src/auth/guard-auth.module.ts
src/auth/guards/permission.guard.ts
src/auth/guards/superadmin.guard.ts
src/auth/guards/tenant-access.guard.ts
src/auth/guards/tenant-admin.guard.ts
src/auth/middlewares/tenant-extractor.middleware.ts
src/auth/permissions/permission-checker.service.ts
src/auth/permissions/permission.enum.ts
src/auth/permissions/permissions.service.ts
src/auth/roles/roles.service.ts
src/catalogs/cat-cie-diez/cat-cie-diez.controller.spec.ts
src/catalogs/cat-cie-diez/cat-cie-diez.controller.ts
src/catalogs/cat-cie-diez/cat-cie-diez.module.ts
src/catalogs/cat-cie-diez/cat-cie-diez.service.spec.ts
src/catalogs/cat-cie-diez/cat-cie-diez.service.ts
src/catalogs/cat-cie-diez/dto/create-cat-cie-diez.dto.ts
src/catalogs/cat-cie-diez/dto/update-cat-cie-diez.dto.ts
src/catalogs/cat-cie-diez/entities/cat-cie-diez.entity.ts
src/catalogs/cat-measure-unit/cat-measure-unit.controller.ts
src/catalogs/cat-measure-unit/cat-measure-unit.interface.ts
src/catalogs/cat-measure-unit/cat-measure-unit.module.ts
src/catalogs/cat-measure-unit/cat-measure-unit.service.ts
src/catalogs/cat-measure-unit/dto/create-cat-measure-unit.dto.ts
src/catalogs/cat-study-type/cat-study-type.controller.ts
src/catalogs/cat-study-type/cat-study-type.interface.ts
src/catalogs/cat-study-type/cat-study-type.module.ts
src/catalogs/cat-study-type/cat-study-type.service.ts
src/catalogs/cat-vital-signs/cat-vital-signs.controller.ts
src/catalogs/cat-vital-signs/cat-vital-signs.interface.ts
src/catalogs/cat-vital-signs/cat-vital-signs.module.ts
src/catalogs/cat-vital-signs/cat-vital-signs.service.ts
src/catalogs/cat-vital-signs/dto/create-cat-vital-signs.dto.ts
src/catalogs/subcat-cie-diez/dto/create-subcat-cie-diez.dto.ts
src/catalogs/subcat-cie-diez/dto/update-subcat-cie-diez.dto.ts
src/catalogs/subcat-cie-diez/entities/subcat-cie-diez.entity.ts
src/catalogs/subcat-cie-diez/subcat-cie-diez.controller.spec.ts
src/catalogs/subcat-cie-diez/subcat-cie-diez.controller.ts
src/catalogs/subcat-cie-diez/subcat-cie-diez.module.ts
src/catalogs/subcat-cie-diez/subcat-cie-diez.service.spec.ts
src/catalogs/subcat-cie-diez/subcat-cie-diez.service.ts
src/main.ts
src/management/auth/auth.controller.spec.ts
src/management/auth/auth.controller.ts
src/management/auth/auth.module.ts
src/management/auth/auth.service.spec.ts
src/management/auth/auth.service.ts
src/management/auth/dto/create-auth.dto.ts
src/management/auth/dto/password-auth.dto.ts
src/management/auth/dto/update-auth.dto.ts
src/management/auth/entities/auth.entity.ts
src/management/patient/dto/create-patient.dto.ts
src/management/patient/dto/get-patient.dto.ts
src/management/patient/dto/medical-patient.dto.ts
src/management/patient/dto/update-patient.dto.ts
src/management/patient/entities/patient.interface.ts
src/management/patient/patient.controller.spec.ts
src/management/patient/patient.controller.ts
src/management/patient/patient.module.ts
src/management/patient/patient.service.spec.ts
src/management/patient/patient.service.ts
src/management/suscription/paypal/paypal.controller.ts
src/management/suscription/paypal/paypal.module.ts
src/management/suscription/paypal/services/paypal.service.ts
src/management/suscription/paypal/services/transaction.service.ts
src/management/user/dto/create-user.dto.ts
src/management/user/dto/onboarding-user.dto.ts
src/management/user/dto/update-user.dto.ts
src/management/user/entities/user.interface.ts
src/management/user/roles.enum.ts
src/management/user/user.controller.spec.ts
src/management/user/user.controller.ts
src/management/user/user.module.ts
src/management/user/user.service.spec.ts
src/management/user/user.service.ts
src/medical-scheduling/appointments/appointments.controller.ts
src/medical-scheduling/appointments/appointments.module.ts
src/medical-scheduling/appointments/appointments.service.ts
src/medical-scheduling/appointments/dto/create-appointment.dto.ts
src/medical-scheduling/medical-events/dto/create-medical-event.dto.ts
src/medical-scheduling/medical-events/medical-events.controller.ts
src/medical-scheduling/medical-events/medical-events.module.ts
src/medical-scheduling/medical-events/medical-events.service.ts
src/medical-scheduling/modules/background/background.controller.ts
src/medical-scheduling/modules/background/background.module.ts
src/medical-scheduling/modules/background/background.service.ts
src/medical-scheduling/modules/background/dto/create-background.dto.ts
src/medical-scheduling/modules/medicine/medicine.controller.ts
src/medical-scheduling/modules/medicine/medicine.module.ts
src/medical-scheduling/modules/medicine/medicine.service.ts
src/medical-scheduling/modules/patient-studies/dto/create-patient-study.dto.ts
src/medical-scheduling/modules/patient-studies/dto/update-patient-study.dto.ts
src/medical-scheduling/modules/patient-studies/entities/patient-study.interface.ts
src/medical-scheduling/modules/patient-studies/patient-studies.controller.ts
src/medical-scheduling/modules/patient-studies/patient-studies.module.ts
src/medical-scheduling/modules/patient-studies/patient-studies.service.ts
src/medical-scheduling/modules/physical-examination-data/physical_subsystem/physical_subsystem.interface.ts
src/medical-scheduling/modules/physical-examination-data/physical_subsystem/physical_subsystem.service.ts
src/medical-scheduling/modules/physical-examination-data/physical-examination/physical_examination.interface.ts
src/medical-scheduling/modules/physical-examination-data/physical-examination/physical-examination.service.ts
src/medical-scheduling/modules/physical-exploration-data/physical-exploration-area/dto/create-physical-exploration-area.dto.ts
src/medical-scheduling/modules/physical-exploration-data/physical-exploration-area/physical-exploration-area.controller.ts
src/medical-scheduling/modules/physical-exploration-data/physical-exploration-area/physical-exploration-area.module.ts
src/medical-scheduling/modules/physical-exploration-data/physical-exploration-area/physical-exploration-area.service.ts
src/medical-scheduling/modules/physical-exploration-data/physical-exploration/dto/create-physical-exploration.dto.ts
src/medical-scheduling/modules/physical-exploration-data/physical-exploration/dto/update-physical-exploration.dto.ts
src/medical-scheduling/modules/physical-exploration-data/physical-exploration/physical-exploration.controller.ts
src/medical-scheduling/modules/physical-exploration-data/physical-exploration/physical-exploration.module.ts
src/medical-scheduling/modules/physical-exploration-data/physical-exploration/physical-exploration.service.ts
src/medical-scheduling/modules/pres_mod_history/dto/create-pres-history.dto.ts
src/medical-scheduling/modules/pres_mod_history/dto/update-pres_mod_history.dto.ts
src/medical-scheduling/modules/pres_mod_history/entities/pres_mod_history.entity.ts
src/medical-scheduling/modules/pres_mod_history/pres_mod_history.controller.ts
src/medical-scheduling/modules/pres_mod_history/pres_mod_history.module.ts
src/medical-scheduling/modules/pres_mod_history/pres_mod_history.service.ts
src/medical-scheduling/modules/prescription/dto/create-prescription.dto.ts
src/medical-scheduling/modules/prescription/dto/update-prescription.dto.ts
src/medical-scheduling/modules/prescription/entities/prescription.entity.ts
src/medical-scheduling/modules/prescription/prescription.controller.ts
src/medical-scheduling/modules/prescription/prescription.module.ts
src/medical-scheduling/modules/prescription/prescription.service.ts
src/medical-scheduling/modules/vital-signs/dto/create-vital-sign.dto.ts
src/medical-scheduling/modules/vital-signs/dto/find-vital-signs.dto.ts
src/medical-scheduling/modules/vital-signs/dto/update-vital-sign.dto.ts
src/medical-scheduling/modules/vital-signs/vital-signs.controller.ts
src/medical-scheduling/modules/vital-signs/vital-signs.module.ts
src/medical-scheduling/modules/vital-signs/vital-signs.service.ts
src/mobile-functions/mobile-functions.module.ts
src/mobile-functions/self-evaluation-event/dto/create-self-evaluation-event.dto.ts
src/mobile-functions/self-evaluation-event/self-evaluation-event.controller.ts
src/mobile-functions/self-evaluation-event/self-evaluation-event.module.ts
src/mobile-functions/self-evaluation-event/self-evaluation-event.service.ts
src/prisma/prisma.module.ts
src/prisma/prisma.service.ts
src/services/email/email.module.ts
src/services/email/email.service.ts
src/services/email/templates/credentialsHtml.ts
src/services/email/templates/recoverPasswordHtml.ts
src/services/email/templates/welcomeEmailHtml.ts
src/services/twilio/twilio.module.ts
src/services/twilio/twilio.service.ts
src/utils/auth.helper.ts
src/utils/cloudinary.ts
src/utils/file_upload/file_upload.controller.ts
src/utils/file_upload/file_upload.module.ts
src/utils/file_upload/file_upload.repository.ts
src/utils/file_upload/file_upload.service.ts
src/utils/middlewares/tenantMiddleware.ts
src/utils/middlewares/tenantPrismaMiddleware.ts
src/utils/pagination.helper.ts
test/app.e2e-spec.ts
test/jest-e2e.json
tsconfig.build.json
tsconfig.json

================================================================
Files
================================================================

================
File: .dockerignore
================
node_modules
dist
.env
logs

================
File: .eslintrc.js
================
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};

================
File: .gitignore
================
# compiled output
/dist
/node_modules
/build

prisma/migrations/

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

================
File: .prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: DockerFile
================
# Stage 1: Base Development Image
FROM node:18-alpine AS development
WORKDIR /app
ENV HOST=0.0.0.0
ENV PORT=5000
ENV NODE_ENV=development
EXPOSE 5000
COPY package.json package-lock.json ./
RUN npm install
COPY . .
CMD ["npm", "run", "start:dev"]

# Stage 2: Install Dependencies
FROM node:18-alpine AS dependencies
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm install --production

# Stage 3: Build Application
FROM node:18-alpine AS builder
WORKDIR /app
COPY --from=dependencies /app/node_modules ./node_modules
COPY . .
RUN npm run build

# Stage 4: Production Image
FROM node:18-alpine AS production
WORKDIR /app
ENV HOST=0.0.0.0
ENV PORT=5000
ENV NODE_ENV=production
COPY --from=builder /app/package.json /app/package-lock.json ./
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
USER node
EXPOSE 5000
CMD ["node", "dist/main"]

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true,
    "plugins": [
    {
      "name": "@nestjs/swagger",
      "options": {
        "classValidatorShim": true,
        "introspectComments": true
      }
    }
  ]
  }
}

================
File: package.json
================
{
  "name": "segimed-backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "prisma": "prisma generate && prisma db push"
  },
  "dependencies": {
    "@nestjs/axios": "^4.0.0",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.3.0",
    "@nestjs/core": "^10.4.15",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/mapped-types": "*",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/swagger": "^8.1.0",
    "@nestjs/typeorm": "^10.0.2",
    "@paypal/checkout-server-sdk": "^1.0.3",
    "@prisma/client": "^6.4.1",
    "@types/jsonwebtoken": "^9.0.7",
    "axios": "^1.8.1",
    "bcrypt": "^5.1.1",
    "buffer-to-stream": "^1.0.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "cloudinary": "^2.5.1",
    "dotenv": "^16.4.7",
    "express-openid-connect": "^2.17.1",
    "multer": "^1.4.5-lts.1",
    "googleapis": "^144.0.0",
    "pg": "^8.13.1",
    "reflect-metadata": "^0.2.0",
    "rxjs": "^7.8.1",
    "twilio": "^5.4.3",
    "typeorm": "^0.3.20",
    "uuid": "^11.0.3",
    "whatsapp-web.js": "^1.26.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/buffer-to-stream": "^1.0.3",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint": "^8.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "prisma": "^6.4.1",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

================
File: prisma/schema.prisma
================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model tenant {
  id         String      @id @default(uuid())
  type       tenant_type
  db_name    String?
  created_at DateTime    @default(now())
  updated_at DateTime    @updatedAt
  deleted    Boolean     @default(false)

  users                  user[]
  organizations          organization[]
  physicians             physician[]
  appointments           appointment[]
  medical_events         medical_event[]
  organization_physician organization_physician[]
  patient_tenant         patient_tenant[]
  prescription           prescription[]
  transaction            transaction[]
  background             background[]
  physical_exploration   physical_exploration[]
  vital_signs            vital_signs[]
  self_evaluation_event  self_evaluation_event[]
  role                   role[]
}

model user {
  id                    String                 @id @default(uuid())
  name                  String
  last_name             String?
  email                 String                 @unique
  password              String?
  role                  role_type              @default(physician)
  is_superadmin         Boolean                @default(false)
  nationality           String?
  gender                String?
  dni                   String?                @unique
  birth_date            DateTime?
  phone_prefix          String?
  phone                 String?
  is_phone_verified     Boolean                @default(false)
  image                 String                 @default("https://cdn.pixabay.com/photo/2015/10/05/22/37/blank-profile-picture-973460_1280.png")
  created_at            DateTime               @default(now())
  updated_at            DateTime               @updatedAt
  deleted               Boolean                @default(false)
  deleted_at            DateTime?
  transactions          transaction[]
  physical_examinations physical_examination[]

  tenant_id String?
  patient   patient?
  tenant    tenant?  @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  physicianAppointment appointment[]      @relation(name: "physician")
  patientAppointments  appointment[]      @relation(name: "patient")
  physician            physician[]
  prescription         prescription[]
  pres_mod_history     pres_mod_history[]
  background           background[]

  self_evaluation_event self_evaluation_event[]
  vital_signs           vital_signs[]

  roles user_role[]

  physical_exploration_physician physical_exploration[] @relation("physician")
  physical_exploration_patient   physical_exploration[] @relation("patient")
}

model organization {
  id                  String      @id @default(uuid())
  name                String
  type                tenant_type
  number_of_employees Int?
  number_of_patients  Int?
  reason_register     String
  created_at          DateTime    @default(now())
  updated_at          DateTime    @updatedAt
  deleted             Boolean     @default(false)
  deleted_at          DateTime?

  tenant_id              String?
  tenant                 tenant?                  @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  organization_physician organization_physician[]
}

model organization_physician {
  id              String       @id @default(uuid())
  organization_id String
  physician_id    String
  created_at      DateTime     @default(now())
  updated_at      DateTime     @updatedAt
  deleted         Boolean      @default(false)
  deleted_at      DateTime?
  organization    organization @relation(fields: [organization_id], references: [id], onDelete: Cascade)
  physician       physician    @relation(fields: [physician_id], references: [id], onDelete: Cascade)
  tenant_id       String
  tenant          tenant?      @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
}

model patient {
  id                 String    @id @default(uuid())
  direction          String?
  country            String?
  province           String?
  city               String?
  postal_code        String?
  direction_number   String?
  apartment          String?
  health_care_number String?
  notes              String?
  created_at         DateTime  @default(now())
  updated_at         DateTime  @updatedAt
  deleted            Boolean   @default(false)
  deleted_at         DateTime?
  user_id            String    @unique
  user               user      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  medical_event  medical_event[]
  patient_tenant patient_tenant[]
}

model patient_tenant {
  id         String    @id @default(uuid())
  patient_id String
  patient    patient   @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  tenant_id  String
  tenant     tenant    @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted    Boolean   @default(false)
  deleted_at DateTime?

  @@unique([patient_id, tenant_id])
}

model physician {
  id               String    @id @default(uuid())
  user_id          String
  user             user      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  tenant_id        String?
  tenant           tenant?   @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  medical_registry String?
  created_at       DateTime  @default(now())
  updated_at       DateTime  @updatedAt
  deleted          Boolean   @default(false)
  deleted_at       DateTime?

  medical_event          medical_event[]
  physician_speciality   physician_speciality[]
  organization_physician organization_physician[]
}

model appointment {
  id                  String          @id @default(uuid())
  consultation_reason String
  start               DateTime
  end                 DateTime
  patient_id          String
  physician_id        String
  status              status_type     @default(pendiente)
  cancelation_reason  String?
  comments            String?
  created_at          DateTime        @default(now())
  updated_at          DateTime        @updatedAt
  deleted             Boolean         @default(false)
  deleted_at          DateTime?
  patient             user            @relation(name: "patient", fields: [patient_id], references: [id], onDelete: Cascade)
  physician           user            @relation(name: "physician", fields: [physician_id], references: [id], onDelete: Cascade)
  medical_events      medical_event[]

  tenant_id String
  tenant    tenant? @relation(fields: [tenant_id], references: [id])
}

model medical_event {
  id                   String                 @id @default(uuid())
  appointment_id       String
  patient_id           String
  physician_id         String
  physician_comments   String?
  main_diagnostic_cie  String?
  evolution            String?
  procedure            String?
  treatment            String?
  created_at           DateTime               @default(now())
  updated_at           DateTime               @updatedAt
  deleted              Boolean                @default(false)
  deleted_at           DateTime?
  appointment          appointment            @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  patient              patient                @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  physician            physician              @relation(fields: [physician_id], references: [id], onDelete: Cascade)
  physical_examination physical_examination[]
  physical_exploration physical_exploration[]

  tenant_id                 String
  tenant                    tenant?                     @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  pres_mod_history          pres_mod_history[]
  subcategory_medical_event subcategory_medical_event[]
  self_evaluation_event     self_evaluation_event[]
  vital_signs               vital_signs[]
}

model transaction {
  id         String    @id @default(uuid())
  orderId    String
  status     String
  amount     Float
  currency   String
  userId     String
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  deleted    Boolean   @default(false)
  deleted_at DateTime?
  user       user      @relation(fields: [userId], references: [id], onDelete: Cascade)

  tenant_id String
  tenant    tenant? @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
}

model patient_study {
  id                String         @id @default(uuid())
  patient_id        String
  physician_id      String
  url               String?        @default("")
  title             String
  description       String
  tenant_id         String
  cat_study_type_id Int
  is_deleted        Boolean        @default(false)
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  cat_study_type    cat_study_type @relation(fields: [cat_study_type_id], references: [id], onDelete: Cascade)

  @@map("patient_studies")
}

model cat_study_type {
  id              Int             @id @default(autoincrement())
  name            String
  patient_studies patient_study[]
}

model password_reset {
  id         String    @id @default(uuid())
  token      String    @unique
  email      String
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  deleted    Boolean   @default(false)
  deleted_at DateTime?
}

model physical_examination {
  id                    String                  @id @default(uuid())
  physical_subsystem_id Int?
  patient_id            String
  description           String
  medical_event_id      String
  created_at            DateTime                @default(now())
  updated_at            DateTime                @updatedAt
  deleted               Boolean                 @default(false)
  deleted_at            DateTime?
  medical_event         medical_event           @relation(fields: [medical_event_id], references: [id], onDelete: Cascade)
  user                  user                    @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  physical_subsystem    cat_physical_subsystem? @relation(fields: [physical_subsystem_id], references: [id])
}

model physical_exploration {
  id                           String @id @default(uuid())
  patient_id                   String
  physician_id                 String
  medical_event_id             String @unique // Only one physical exploration per medical event
  description                  String
  physical_exploration_area_id Int
  tenant_id                    String

  patient                   user                      @relation("patient", fields: [patient_id], references: [id], onDelete: Cascade)
  physician                 user                      @relation("physician", fields: [physician_id], references: [id], onDelete: Cascade)
  medical_event             medical_event             @relation(fields: [medical_event_id], references: [id], onDelete: Cascade)
  physical_exploration_area physical_exploration_area @relation(fields: [physical_exploration_area_id], references: [id])
  tenant                    tenant                    @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
}

model physical_exploration_area {
  id              Int    @id @default(autoincrement())
  name_on_library String @unique
  name            String @unique

  physical_exploration physical_exploration[]
}

model physician_speciality {
  id            String         @id @default(uuid())
  physician_id  String
  speciality_id Int
  created_at    DateTime       @default(now())
  updated_at    DateTime       @updatedAt
  deleted       Boolean        @default(false)
  deleted_at    DateTime?
  physician     physician      @relation(fields: [physician_id], references: [id], onDelete: Cascade)
  speciality    cat_speciality @relation(fields: [speciality_id], references: [id], onDelete: Cascade)
}

model otp_code {
  id              String    @id
  code            String
  code_expires_at DateTime?
}

model background {
  id                        String   @id @default(uuid())
  patient_id                String
  vaccinations              String
  allergies                 String
  pathological_history      String
  family_medical_history    String
  non_pathological_history  String
  surgical_history          String
  childhood_medical_history String
  current_medication        String
  tenant_id                 String
  created_at                DateTime @default(now())
  updated_at                DateTime @updatedAt

  patient user   @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  tenant  tenant @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
}

model subcategory_medical_event {
  id                     String                 @id @default(uuid())
  subCategoryId          Int
  subcategories_cie_diez subcategories_cie_diez @relation(fields: [subCategoryId], references: [id], onDelete: Cascade)
  medical_eventId        String
  medical_event          medical_event          @relation(fields: [medical_eventId], references: [id], onDelete: Cascade)

  @@unique([subCategoryId, medical_eventId])
}

model prescription {
  id               String             @id @default(uuid())
  start_timestamp  DateTime           @default(now())
  end_timestamp    DateTime?
  description      String?
  active           Boolean            @default(true)
  patient_id       String?
  user             user?              @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  monodrug         String
  tenant_id        String?
  tenant           tenant?            @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  pres_mod_history pres_mod_history[]
}

model pres_mod_history {
  id               String         @id @default(uuid())
  prescription_id  String
  prescription     prescription?  @relation(fields: [prescription_id], references: [id], onDelete: Cascade)
  physician_id     String?
  physician        user?          @relation(fields: [physician_id], references: [id], onDelete: Cascade)
  mod_timestamp    DateTime       @default(now())
  medical_event_id String?
  medical_event    medical_event? @relation(fields: [medical_event_id], references: [id], onDelete: Cascade)
  // medical_order_id      String?
  // medical_order         medical_order         @relation(fields: [medical_order_id], references: [id])
  observations     String?
  dose             String
  dose_units       String
  frecuency        String
  duration         String
  duration_units   String
}

model self_evaluation_event {
  id               String        @id @default(uuid())
  patient_id       String
  patient          user          @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  medical_event_id String
  medical_event    medical_event @relation(fields: [medical_event_id], references: [id], onDelete: Cascade)
  tenant_id        String
  tenant           tenant        @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  created_at       DateTime      @default(now())
  updated_at       DateTime      @updatedAt
  vital_signs      vital_signs[]
}

model vital_signs {
  id                       String                 @id @default(uuid())
  patient_id               String
  patient                  user                   @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  medical_event_id         String?
  medical_event            medical_event?         @relation(fields: [medical_event_id], references: [id], onDelete: Cascade)
  self_evaluation_event_id String?
  self_evaluation_event    self_evaluation_event? @relation(fields: [self_evaluation_event_id], references: [id], onDelete: Cascade)
  vital_sign_id            Int
  vital_sign               cat_vital_signs        @relation(fields: [vital_sign_id], references: [id], onDelete: Cascade)
  measure                  Int
  tenant_id                String
  tenant                   tenant?                @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  created_at               DateTime               @default(now())
  updated_at               DateTime               @updatedAt
  deleted                  Boolean                @default(false)
  deleted_at               DateTime?
}

//!Catalogs

model cat_physical_subsystem {
  id                    Int                    @id @default(autoincrement())
  name                  String
  physical_examinations physical_examination[]
  created_at            DateTime               @default(now())
  updated_at            DateTime               @updatedAt
  deleted               Boolean                @default(false)
  deleted_at            DateTime?
}

model cat_speciality {
  id                   Int                    @id @default(autoincrement())
  name                 String
  physician_speciality physician_speciality[]
  created_at           DateTime               @default(now())
  updated_at           DateTime               @updatedAt
  deleted              Boolean                @default(false)
  deleted_at           DateTime?
  cat_vital_signs      cat_vital_signs[]      @relation("SpecialityVitalSigns")
}

model category_cie_diez {
  id                     Int                      @id @default(autoincrement())
  code                   String
  description            String
  subcategories_cie_diez subcategories_cie_diez[]
}

model subcategories_cie_diez {
  id                        Int                         @id @default(autoincrement())
  code                      String
  description               String
  categoryId                Int
  category_cie_diez         category_cie_diez           @relation(fields: [categoryId], references: [id])
  subcategory_medical_event subcategory_medical_event[]
}

model cat_vital_signs {
  id                     Int                @id @default(autoincrement())
  name                   String
  category               String
  vital_signs            vital_signs[]
  cat_vital_sign_measure cat_measure_unit[]

  specialties cat_speciality[] @relation("SpecialityVitalSigns")
}

model cat_measure_unit {
  id                 Int             @id @default(autoincrement())
  name               String
  description        String
  cat_vital_signs_id Int
  cat_vital_signs    cat_vital_signs @relation(fields: [cat_vital_signs_id], references: [id])
}

//!Types

enum role_type {
  patient
  physician
  organization_owner
}

enum status_type {
  atendida
  cancelada
  pendiente
}

enum tenant_type {
  individual
  organization
}

enum gender {
  masculino
  femenino
  otro
}

model role {
  id          String    @id @default(uuid())
  name        String
  description String?
  is_system   Boolean   @default(false)
  tenant_id   String?
  tenant      tenant?   @relation(fields: [tenant_id], references: [id])
  created_at  DateTime  @default(now())
  updated_at  DateTime  @updatedAt
  deleted     Boolean   @default(false)
  deleted_at  DateTime?

  users       user_role[]
  permissions role_permission[]
}

model permission {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  roles role_permission[]
}

model role_permission {
  id            String   @id @default(uuid())
  role_id       String
  permission_id String
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  role       role       @relation(fields: [role_id], references: [id], onDelete: Cascade)
  permission permission @relation(fields: [permission_id], references: [id], onDelete: Cascade)

  @@unique([role_id, permission_id])
}

model user_role {
  id         String   @id @default(uuid())
  user_id    String
  role_id    String
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  user user @relation(fields: [user_id], references: [id], onDelete: Cascade)
  role role @relation(fields: [role_id], references: [id], onDelete: Cascade)

  @@unique([user_id, role_id])
}

================
File: src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: src/app.controller.ts
================
import { Controller } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}
}

================
File: src/app.module.ts
================
import { MiddlewareConsumer, Module, RequestMethod } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UserModule } from './management/user/user.module';
import { AuthModule } from './management/auth/auth.module';
import { JwtModule } from '@nestjs/jwt';
import { config } from 'dotenv';
import { PrismaModule } from './prisma/prisma.module';
import { PrismaService } from './prisma/prisma.service';
import { AppointmentsModule } from './medical-scheduling/appointments/appointments.module';
import { MedicalEventsModule } from './medical-scheduling/medical-events/medical-events.module';
import { PhysicalExaminationService } from './medical-scheduling/modules/physical-examination-data/physical-examination/physical-examination.service';
import { PhysicalSubsystemService } from './medical-scheduling/modules/physical-examination-data/physical_subsystem/physical_subsystem.service';
import { PatientModule } from './management/patient/patient.module';
import { PatientStudiesModule } from './medical-scheduling/modules/patient-studies/patient-studies.module';
import { FileUploadModule } from './utils/file_upload/file_upload.module';
import { CatStudyTypeModule } from './catalogs/cat-study-type/cat-study-type.module';
import { ConfigModule } from '@nestjs/config';
import { EmailModule } from './services/email/email.module';
import { TwilioModule } from './services/twilio/twilio.module';
import { BackgroundModule } from './medical-scheduling/modules/background/background.module';
import { PhysicalExplorationModule } from './medical-scheduling/modules/physical-exploration-data/physical-exploration/physical-exploration.module';
import { PhysicalExplorationAreaModule } from './medical-scheduling/modules/physical-exploration-data/physical-exploration-area/physical-exploration-area.module';
import { CatCieDiezModule } from './catalogs/cat-cie-diez/cat-cie-diez.module';
import { SubcatCieDiezModule } from './catalogs/subcat-cie-diez/subcat-cie-diez.module';
import { MedicineModule } from './medical-scheduling/modules/medicine/medicine.module';
import { PrescriptionModule } from './medical-scheduling/modules/prescription/prescription.module';
import { PresModHistoryModule } from './medical-scheduling/modules/pres_mod_history/pres_mod_history.module';
import { TenantMiddleware } from './utils/middlewares/tenantMiddleware';
import { TenantExtractorMiddleware } from './auth/middlewares/tenant-extractor.middleware';
import { CatVitalSignsModule } from './catalogs/cat-vital-signs/cat-vital-signs.module';
import { CatMeasureUnitModule } from './catalogs/cat-measure-unit/cat-measure-unit.module';
import { GuardAuthModule } from './auth/guard-auth.module';
import { VitalSignsModule } from './medical-scheduling/modules/vital-signs/vital-signs.module';
import { MobileFunctionsModule } from './mobile-functions/mobile-functions.module';

config({ path: '.env' });

@Module({
  imports: [
    GuardAuthModule,
    AppointmentsModule,
    MedicalEventsModule,
    UserModule,
    PatientStudiesModule,
    ConfigModule.forRoot({
      isGlobal: true, // Esto hace que las configuraciones sean accesibles globalmente
      envFilePath: '.env', // El archivo de configuración (debería estar en la raíz)
    }),
    PrismaModule,
    AuthModule,
    FileUploadModule,
    CatStudyTypeModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      global: true,
      signOptions: {
        expiresIn: '7h',
      },
    }),
    PatientModule,
    EmailModule,
    TwilioModule,
    MedicineModule,
    PrescriptionModule,
    PresModHistoryModule,
    BackgroundModule,
    PhysicalExplorationModule,
    PhysicalExplorationAreaModule,
    CatCieDiezModule,
    SubcatCieDiezModule,
    CatVitalSignsModule,
    CatMeasureUnitModule,
    VitalSignsModule,
    MobileFunctionsModule,
  ],
  controllers: [AppController],
  providers: [
    AppService,
    PrismaService,
    PhysicalExaminationService,
    PhysicalSubsystemService,
  ],
})
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(TenantMiddleware)
      .exclude(
        { path: 'auth/register', method: RequestMethod.POST },
        { path: 'auth/', method: RequestMethod.POST },
        { path: 'auth/google', method: RequestMethod.POST },
        { path: 'auth/request-password', method: RequestMethod.POST },
        { path: 'auth/reset-password', method: RequestMethod.POST },
        { path: 'auth/send-otp', method: RequestMethod.POST },
        { path: 'auth/verify-otp', method: RequestMethod.POST },
        { path: 'user/onboarding', method: RequestMethod.POST },
      )
      .forRoutes('*');

    consumer
      .apply(TenantExtractorMiddleware)
      .forRoutes({ path: '*', method: RequestMethod.ALL });
  }
}

================
File: src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: src/auth/controllers/roles.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Put,
  Delete,
  UseGuards,
  BadRequestException,
  NotFoundException,
  Query,
} from '@nestjs/common';
import { RolesService } from '../roles/roles.service';
import { PermissionsService } from '../permissions/permissions.service';
import { RequirePermission } from '../decorators/require-permission.decorator';
import { Permission } from '../permissions/permission.enum';
import { PermissionGuard } from '../guards/permission.guard';
import { TenantAccessGuard } from '../guards/tenant-access.guard';
import { TenantAdminGuard } from '../guards/tenant-admin.guard';
import { SuperAdminGuard } from '../guards/superadmin.guard';

interface CreateRoleDto {
  name: string;
  description?: string;
  permissions: string[];
  tenantId?: string;
}

interface UpdateRoleDto {
  name?: string;
  description?: string;
  permissions?: string[];
}

interface AssignRoleDto {
  userId: string;
  roleId: string;
}

@Controller('roles')
@UseGuards(PermissionGuard)
export class RolesController {
  constructor(
    private readonly rolesService: RolesService,
    private readonly permissionsService: PermissionsService,
  ) {}

  @Get('permissions')
  @UseGuards(TenantAccessGuard)
  @RequirePermission(Permission.CONFIGURE_USER_PERMISSIONS)
  async getAllPermissions() {
    return this.permissionsService.getAllPermissions();
  }

  @Get()
  @UseGuards(TenantAccessGuard)
  @RequirePermission(Permission.CONFIGURE_USER_PERMISSIONS)
  async getRoles(@Query('tenantId') tenantId?: string) {
    return this.rolesService.getRoles(tenantId);
  }

  @Get(':id')
  @UseGuards(TenantAccessGuard)
  @RequirePermission(Permission.CONFIGURE_USER_PERMISSIONS)
  async getRoleById(@Param('id') id: string) {
    try {
      return await this.rolesService.getRoleById(id);
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException(
        `Error al obtener el rol: ${error.message}`,
      );
    }
  }

  @Post()
  @UseGuards(TenantAdminGuard)
  @RequirePermission(Permission.CONFIGURE_USER_PERMISSIONS)
  async createRole(@Body() createRoleDto: CreateRoleDto) {
    try {
      return await this.rolesService.createRole(createRoleDto);
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException(`Error al crear el rol: ${error.message}`);
    }
  }

  @Put(':id')
  @UseGuards(TenantAdminGuard)
  @RequirePermission(Permission.CONFIGURE_USER_PERMISSIONS)
  async updateRole(
    @Param('id') id: string,
    @Body() updateRoleDto: UpdateRoleDto,
  ) {
    try {
      return await this.rolesService.updateRole(id, updateRoleDto);
    } catch (error) {
      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Error al actualizar el rol: ${error.message}`,
      );
    }
  }

  @Delete(':id')
  @UseGuards(TenantAdminGuard)
  @RequirePermission(Permission.CONFIGURE_USER_PERMISSIONS)
  async deleteRole(@Param('id') id: string) {
    try {
      return await this.rolesService.deleteRole(id);
    } catch (error) {
      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Error al eliminar el rol: ${error.message}`,
      );
    }
  }

  @Post('assign')
  @UseGuards(TenantAdminGuard)
  @RequirePermission(Permission.CONFIGURE_USER_PERMISSIONS)
  async assignRoleToUser(@Body() assignRoleDto: AssignRoleDto) {
    try {
      return await this.rolesService.assignRoleToUser(
        assignRoleDto.userId,
        assignRoleDto.roleId,
      );
    } catch (error) {
      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Error al asignar rol al usuario: ${error.message}`,
      );
    }
  }

  @Delete('assign')
  @UseGuards(TenantAdminGuard)
  @RequirePermission(Permission.CONFIGURE_USER_PERMISSIONS)
  async removeRoleFromUser(@Body() assignRoleDto: AssignRoleDto) {
    try {
      return await this.rolesService.removeRoleFromUser(
        assignRoleDto.userId,
        assignRoleDto.roleId,
      );
    } catch (error) {
      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Error al eliminar rol del usuario: ${error.message}`,
      );
    }
  }

  @Get('user/:userId')
  @UseGuards(TenantAccessGuard)
  @RequirePermission(Permission.CONFIGURE_USER_PERMISSIONS)
  async getUserRoles(@Param('userId') userId: string) {
    try {
      return await this.rolesService.getUserRoles(userId);
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException(
        `Error al obtener roles del usuario: ${error.message}`,
      );
    }
  }

  @Post('seed')
  @UseGuards(SuperAdminGuard)
  async seedRolesAndPermissions() {
    try {
      // Primero crear los permisos
      await this.permissionsService.seedPermissions();

      // Luego crear los roles por defecto
      return await this.rolesService.seedDefaultRoles();
    } catch (error) {
      throw new BadRequestException(
        `Error al crear roles y permisos por defecto: ${error.message}`,
      );
    }
  }
}

================
File: src/auth/decorators/require-permission.decorator.ts
================
import { SetMetadata } from '@nestjs/common';
import { Permission } from '../permissions/permission.enum';

export const PERMISSION_KEY = 'permission';

export const RequirePermission = (permission: Permission) =>
  SetMetadata(PERMISSION_KEY, permission);

================
File: src/auth/guard-auth.module.ts
================
import { Module } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { PermissionsService } from './permissions/permissions.service';
import { RolesService } from './roles/roles.service';
import { PermissionCheckerService } from './permissions/permission-checker.service';
import { PermissionGuard } from './guards/permission.guard';
import { TenantAccessGuard } from './guards/tenant-access.guard';
import { TenantAdminGuard } from './guards/tenant-admin.guard';
import { SuperAdminGuard } from './guards/superadmin.guard';
import { RolesController } from './controllers/roles.controller';

@Module({
  controllers: [RolesController],
  providers: [
    PrismaService,
    PermissionsService,
    RolesService,
    PermissionCheckerService,
    PermissionGuard,
    TenantAccessGuard,
    TenantAdminGuard,
    SuperAdminGuard,
  ],
  exports: [
    PermissionsService,
    RolesService,
    PermissionCheckerService,
    PermissionGuard,
    TenantAccessGuard,
    TenantAdminGuard,
    SuperAdminGuard,
  ],
})
export class GuardAuthModule {}

================
File: src/auth/guards/permission.guard.ts
================
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { PermissionCheckerService } from '../permissions/permission-checker.service';
import { PERMISSION_KEY } from '../decorators/require-permission.decorator';

@Injectable()
export class PermissionGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private permissionChecker: PermissionCheckerService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredPermission = this.reflector.getAllAndOverride<string>(
      PERMISSION_KEY,
      [context.getHandler(), context.getClass()],
    );

    // Si no se requiere permiso específico, permitir acceso
    if (!requiredPermission) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const userId = request.user?.id;
    const tenantId = request.tenant?.id;

    // Si no hay usuario autenticado, denegar acceso
    if (!userId) {
      throw new ForbiddenException('No autorizado');
    }

    // Verificar si el usuario tiene el permiso requerido
    const hasPermission = await this.permissionChecker.hasPermission(
      userId,
      requiredPermission,
      tenantId,
    );

    if (!hasPermission) {
      throw new ForbiddenException(`No tiene permiso: ${requiredPermission}`);
    }

    return true;
  }
}

================
File: src/auth/guards/superadmin.guard.ts
================
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';

@Injectable()
export class SuperAdminGuard implements CanActivate {
  constructor(private prisma: PrismaService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const userId = request.user?.id;

    // Si no hay usuario autenticado, denegar acceso
    if (!userId) {
      throw new ForbiddenException('No autorizado');
    }

    // Verificar si el usuario es superadmin
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: { is_superadmin: true },
    });

    if (!user || !user.is_superadmin) {
      throw new ForbiddenException(
        'Se requieren permisos de superadministrador',
      );
    }

    return true;
  }
}

================
File: src/auth/guards/tenant-access.guard.ts
================
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
} from '@nestjs/common';
import { PermissionCheckerService } from '../permissions/permission-checker.service';

@Injectable()
export class TenantAccessGuard implements CanActivate {
  constructor(private permissionChecker: PermissionCheckerService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const userId = request.user?.id;
    const tenantId = request.tenant?.id;

    // Si no hay usuario autenticado o tenant, denegar acceso
    if (!userId || !tenantId) {
      throw new ForbiddenException('No autorizado');
    }

    // Verificar si el usuario tiene acceso al tenant
    const hasAccess = await this.permissionChecker.hasAccessToTenant(
      userId,
      tenantId,
    );

    if (!hasAccess) {
      throw new ForbiddenException('No tiene acceso a esta organización');
    }

    return true;
  }
}

================
File: src/auth/guards/tenant-admin.guard.ts
================
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
} from '@nestjs/common';
import { PermissionCheckerService } from '../permissions/permission-checker.service';

@Injectable()
export class TenantAdminGuard implements CanActivate {
  constructor(private permissionChecker: PermissionCheckerService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const userId = request.user?.id;
    const tenantId = request.tenant?.id;

    // Si no hay usuario autenticado o tenant, denegar acceso
    if (!userId || !tenantId) {
      throw new ForbiddenException('No autorizado');
    }

    // Verificar si el usuario es admin del tenant
    const isAdmin = await this.permissionChecker.isAdminOfTenant(
      userId,
      tenantId,
    );

    if (!isAdmin) {
      throw new ForbiddenException('Se requieren permisos de administrador');
    }

    return true;
  }
}

================
File: src/auth/middlewares/tenant-extractor.middleware.ts
================
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { PrismaService } from '../../prisma/prisma.service';

@Injectable()
export class TenantExtractorMiddleware implements NestMiddleware {
  constructor(private prisma: PrismaService) {}

  async use(req: Request, res: Response, next: NextFunction) {
    // Obtener el tenant ID de los headers, query params o body
    const tenantId =
      (req.headers['x-tenant-id'] as string) ||
      (req.query.tenantId as string) ||
      (req.body && req.body.tenantId);

    if (tenantId) {
      try {
        // Verificar si el tenant existe
        const tenant = await this.prisma.tenant.findUnique({
          where: { id: tenantId },
          select: { id: true, type: true, db_name: true },
        });

        if (tenant) {
          // Agregar el tenant al request para que esté disponible en los controladores
          req['tenant'] = tenant;
        }
      } catch (error) {
        // Si hay un error, simplemente continuar sin tenant
        console.error('Error al obtener tenant:', error);
      }
    }

    next();
  }
}

================
File: src/auth/permissions/permission-checker.service.ts
================
import { Injectable, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { Permission } from './permission.enum';

@Injectable()
export class PermissionCheckerService {
  constructor(private prisma: PrismaService) {}

  /**
   * Verifica si un usuario tiene un permiso específico
   */
  async hasPermission(
    userId: string,
    permissionName: string,
    tenantId?: string,
  ): Promise<boolean> {
    try {
      // Verificar si el usuario existe
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new ForbiddenException('Usuario no encontrado');
      }

      // Si el usuario es superadmin, tiene todos los permisos
      if (user.is_superadmin) {
        return true;
      }

      // Verificar si el usuario tiene el permiso a través de sus roles
      const userRoles = await this.prisma.user_role.findMany({
        where: { user_id: userId },
        include: {
          role: {
            include: {
              permissions: {
                include: {
                  permission: true,
                },
              },
            },
          },
        },
      });

      // Si el usuario no tiene roles, no tiene permisos
      if (userRoles.length === 0) {
        return false;
      }

      // Verificar si alguno de los roles del usuario tiene el permiso solicitado
      for (const userRole of userRoles) {
        const role = userRole.role;

        // Si es un rol de sistema, aplica para todos los tenants
        // Si no es un rol de sistema, verificar que coincida el tenant
        if (role.is_system || !tenantId || role.tenant_id === tenantId) {
          // Verificar si el rol tiene el permiso
          const hasPermission = role.permissions.some(
            (rp) => rp.permission.name === permissionName,
          );

          if (hasPermission) {
            return true;
          }
        }
      }

      return false;
    } catch (error) {
      if (error instanceof ForbiddenException) {
        throw error;
      }
      throw new ForbiddenException('Error al verificar permisos');
    }
  }

  /**
   * Verifica si un usuario tiene acceso a un tenant específico
   */
  async hasAccessToTenant(userId: string, tenantId: string): Promise<boolean> {
    try {
      // Verificar si el usuario existe
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new ForbiddenException('Usuario no encontrado');
      }

      // Si el usuario es superadmin, tiene acceso a todos los tenants
      if (user.is_superadmin) {
        return true;
      }

      // Si el usuario pertenece al tenant, tiene acceso
      if (user.tenant_id === tenantId) {
        return true;
      }

      // Verificar si el usuario tiene roles asociados al tenant
      const userRoles = await this.prisma.user_role.findMany({
        where: { user_id: userId },
        include: {
          role: true,
        },
      });

      // Verificar si alguno de los roles del usuario está asociado al tenant
      return userRoles.some(
        (userRole) =>
          userRole.role.tenant_id === tenantId || userRole.role.is_system,
      );
    } catch (error) {
      if (error instanceof ForbiddenException) {
        throw error;
      }
      throw new ForbiddenException('Error al verificar acceso al tenant');
    }
  }

  /**
   * Verifica si un usuario es admin de un tenant específico
   */
  async isAdminOfTenant(userId: string, tenantId: string): Promise<boolean> {
    try {
      // Verificar si el usuario existe
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new ForbiddenException('Usuario no encontrado');
      }

      // Si el usuario es superadmin, es admin de todos los tenants
      if (user.is_superadmin) {
        return true;
      }

      // Verificar si el usuario tiene el rol de Admin en el tenant
      const userRoles = await this.prisma.user_role.findMany({
        where: { user_id: userId },
        include: {
          role: true,
        },
      });

      // Verificar si el usuario tiene el rol de Admin en el tenant
      return userRoles.some(
        (userRole) =>
          userRole.role.name === 'Admin' &&
          (userRole.role.tenant_id === tenantId || userRole.role.is_system),
      );
    } catch (error) {
      if (error instanceof ForbiddenException) {
        throw error;
      }
      throw new ForbiddenException('Error al verificar si es admin del tenant');
    }
  }

  /**
   * Obtiene todos los permisos de un usuario
   */
  async getUserPermissions(
    userId: string,
    tenantId?: string,
  ): Promise<string[]> {
    try {
      // Verificar si el usuario existe
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new ForbiddenException('Usuario no encontrado');
      }

      // Si el usuario es superadmin, tiene todos los permisos
      if (user.is_superadmin) {
        return Object.values(Permission);
      }

      // Obtener roles del usuario
      const userRoles = await this.prisma.user_role.findMany({
        where: { user_id: userId },
        include: {
          role: {
            include: {
              permissions: {
                include: {
                  permission: true,
                },
              },
            },
          },
        },
      });

      // Recopilar permisos únicos de todos los roles aplicables
      const permissions = new Set<string>();

      for (const userRole of userRoles) {
        const role = userRole.role;

        // Si es un rol de sistema, aplica para todos los tenants
        // Si no es un rol de sistema, verificar que coincida el tenant
        if (role.is_system || !tenantId || role.tenant_id === tenantId) {
          // Agregar permisos del rol
          for (const rolePermission of role.permissions) {
            permissions.add(rolePermission.permission.name);
          }
        }
      }

      return Array.from(permissions);
    } catch (error) {
      if (error instanceof ForbiddenException) {
        throw error;
      }
      throw new ForbiddenException('Error al obtener permisos del usuario');
    }
  }
}

================
File: src/auth/permissions/permission.enum.ts
================
export enum Permission {
  // Gestión de Médicos
  VIEW_DOCTORS_LIST = 'ver_listado_de_medicos',
  VIEW_DOCTOR_DETAILS = 'ver_detalles_de_medico',
  EDIT_DOCTOR_INFO = 'editar_informacion_de_medico',
  DELETE_DOCTORS = 'eliminar_medicos',
  ACCESS_DOCTOR_INDICATORS = 'acceder_a_indicadores_de_medicos',

  // Gestión de Pacientes
  VIEW_PATIENTS_LIST = 'ver_listado_de_pacientes',
  VIEW_PATIENT_DETAILS = 'ver_detalles_de_paciente',
  EDIT_PATIENT_INFO = 'editar_informacion_de_paciente',
  DELETE_PATIENTS = 'eliminar_pacientes',
  ACCESS_PATIENT_INDICATORS = 'acceder_a_indicadores_del_paciente',

  // Tratamientos y Diagnósticos
  ASSIGN_TREATMENTS = 'asignar_tratamientos_a_pacientes',
  MODIFY_TREATMENTS = 'modificar_tratamientos_asignados',
  VIEW_TREATMENT_HISTORY = 'ver_historial_de_tratamientos',
  ADD_DIAGNOSES = 'agregar_diagnosticos_medicos',
  EDIT_DIAGNOSES = 'editar_diagnosticos',

  // Reportes de Gestión
  VIEW_ACTIVITY_REPORTS = 'ver_reportes_de_actividad',
  GENERATE_CONSULTATION_REPORTS = 'generar_reportes_de_consultas_atendidas',
  GENERATE_ADHERENCE_REPORTS = 'generar_reportes_de_adherencia_al_tratamiento',
  DOWNLOAD_REPORTS = 'descargar_reportes_en_pdf_o_excel',

  // Administración y Configuración
  MANAGE_USERS = 'gestion_de_usuarios',
  CONFIGURE_USER_PERMISSIONS = 'configuracion_de_permisos_de_usuarios',
  DEFINE_STATISTICS_ACCESS = 'definir_acceso_a_estadisticas_y_reportes',
  CONFIGURE_ALERTS = 'configuracion_de_alertas_y_notificaciones',
  MANAGE_SPECIALTIES = 'gestion_de_especialidades_medicas',

  // Agenda y Turnos
  SCHEDULE_APPOINTMENTS = 'agendar_consultas_para_pacientes',
  EDIT_CANCEL_APPOINTMENTS = 'editar_y_cancelar_citas',
  CONFIRM_PATIENT_ATTENDANCE = 'confirmar_asistencia_del_paciente',
  BLOCK_SCHEDULE = 'bloquear_horarios_en_la_agenda',
  AUTOMATIC_REMINDERS = 'recordatorios_automaticos_de_citas',

  // Catálogos
  MANAGE_CATALOGS = 'gestionar_catalogos',
}

================
File: src/auth/permissions/permissions.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { Permission } from './permission.enum';

@Injectable()
export class PermissionsService {
  constructor(private prisma: PrismaService) {}

  async seedPermissions() {
    // Obtener todos los permisos existentes
    const existingPermissions = await this.prisma.permission.findMany();
    const existingPermissionNames = existingPermissions.map((p) => p.name);

    // Crear permisos que no existen
    const permissionsToCreate = Object.values(Permission)
      .filter((permission) => !existingPermissionNames.includes(permission))
      .map((permission) => ({
        name: permission,
        description: this.getPermissionDescription(permission),
      }));

    if (permissionsToCreate.length > 0) {
      await this.prisma.permission.createMany({
        data: permissionsToCreate,
        skipDuplicates: true,
      });
    }

    return this.prisma.permission.findMany();
  }

  async getAllPermissions() {
    return this.prisma.permission.findMany({
      orderBy: { name: 'asc' },
    });
  }

  async getPermissionById(id: string) {
    const permission = await this.prisma.permission.findUnique({
      where: { id },
    });

    if (!permission) {
      throw new NotFoundException(`Permiso con ID ${id} no encontrado`);
    }

    return permission;
  }

  async getPermissionByName(name: string) {
    const permission = await this.prisma.permission.findUnique({
      where: { name },
    });

    if (!permission) {
      throw new NotFoundException(`Permiso con nombre ${name} no encontrado`);
    }

    return permission;
  }

  private getPermissionDescription(permissionName: string): string {
    const descriptions = {
      [Permission.VIEW_DOCTORS_LIST]: 'Ver listado de médicos',
      [Permission.VIEW_DOCTOR_DETAILS]: 'Ver detalles de médico',
      [Permission.EDIT_DOCTOR_INFO]: 'Editar información de médico',
      [Permission.DELETE_DOCTORS]: 'Eliminar médicos',
      [Permission.ACCESS_DOCTOR_INDICATORS]:
        'Acceder a indicadores de médicos (consultas atendidas, rendimiento, calificación, etc.)',

      [Permission.VIEW_PATIENTS_LIST]: 'Ver listado de pacientes',
      [Permission.VIEW_PATIENT_DETAILS]: 'Ver detalles de paciente',
      [Permission.EDIT_PATIENT_INFO]: 'Editar información de paciente',
      [Permission.DELETE_PATIENTS]: 'Eliminar pacientes',
      [Permission.ACCESS_PATIENT_INDICATORS]:
        'Acceder a indicadores del paciente (estadísticas, adherencia, alarmas, etc.)',

      [Permission.ASSIGN_TREATMENTS]: 'Asignar tratamientos a pacientes',
      [Permission.MODIFY_TREATMENTS]: 'Modificar tratamientos asignados',
      [Permission.VIEW_TREATMENT_HISTORY]: 'Ver historial de tratamientos',
      [Permission.ADD_DIAGNOSES]: 'Agregar diagnósticos médicos',
      [Permission.EDIT_DIAGNOSES]: 'Editar diagnósticos',

      [Permission.VIEW_ACTIVITY_REPORTS]:
        'Ver reportes de actividad (médicos y pacientes)',
      [Permission.GENERATE_CONSULTATION_REPORTS]:
        'Generar reportes de consultas atendidas',
      [Permission.GENERATE_ADHERENCE_REPORTS]:
        'Generar reportes de adherencia al tratamiento',
      [Permission.DOWNLOAD_REPORTS]: 'Descargar reportes en PDF o Excel',

      [Permission.MANAGE_USERS]:
        'Gestión de usuarios (crear, editar, eliminar roles)',
      [Permission.CONFIGURE_USER_PERMISSIONS]:
        'Configuración de permisos de usuarios',
      [Permission.DEFINE_STATISTICS_ACCESS]:
        'Definir acceso a estadísticas y reportes',
      [Permission.CONFIGURE_ALERTS]:
        'Configuración de alertas y notificaciones',
      [Permission.MANAGE_SPECIALTIES]: 'Gestión de especialidades médicas',

      [Permission.SCHEDULE_APPOINTMENTS]: 'Agendar consultas para pacientes',
      [Permission.EDIT_CANCEL_APPOINTMENTS]: 'Editar y cancelar citas',
      [Permission.CONFIRM_PATIENT_ATTENDANCE]:
        'Confirmar asistencia del paciente',
      [Permission.BLOCK_SCHEDULE]: 'Bloquear horarios en la agenda',
      [Permission.AUTOMATIC_REMINDERS]: 'Recordatorios automáticos de citas',

      [Permission.MANAGE_CATALOGS]: 'Gestionar catálogos del sistema',
    };

    return descriptions[permissionName] || permissionName;
  }
}

================
File: src/auth/roles/roles.service.ts
================
import {
  Injectable,
  BadRequestException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { Permission } from '../permissions/permission.enum';

interface CreateRoleDto {
  name: string;
  description?: string;
  permissions: string[];
  tenantId?: string;
  isSystem?: boolean;
}

interface UpdateRoleDto {
  name?: string;
  description?: string;
  permissions?: string[];
}

@Injectable()
export class RolesService {
  constructor(private prisma: PrismaService) {}

  async seedDefaultRoles() {
    // Crear roles por defecto si no existen
    const defaultRoles = [
      {
        name: 'SuperAdmin',
        description: 'Administrador con acceso completo al sistema',
        isSystem: true,
        permissions: Object.values(Permission),
      },
      {
        name: 'Admin',
        description: 'Administrador de organización',
        isSystem: true,
        permissions: Object.values(Permission),
      },
      {
        name: 'Secretario',
        description: 'Secretario con permisos limitados',
        isSystem: true,
        permissions: [
          Permission.VIEW_DOCTORS_LIST,
          Permission.VIEW_DOCTOR_DETAILS,
          Permission.VIEW_PATIENTS_LIST,
          Permission.VIEW_PATIENT_DETAILS,
          Permission.SCHEDULE_APPOINTMENTS,
          Permission.EDIT_CANCEL_APPOINTMENTS,
          Permission.CONFIRM_PATIENT_ATTENDANCE,
        ],
      },
    ];

    for (const roleData of defaultRoles) {
      const existingRole = await this.prisma.role.findFirst({
        where: { name: roleData.name, is_system: true },
      });

      if (!existingRole) {
        await this.createRole({
          name: roleData.name,
          description: roleData.description,
          permissions: roleData.permissions,
          isSystem: roleData.isSystem,
        });
      }
    }

    return this.prisma.role.findMany({
      where: { is_system: true },
      include: { permissions: { include: { permission: true } } },
    });
  }

  async createRole(data: CreateRoleDto) {
    try {
      // Verificar si ya existe un rol con el mismo nombre en el mismo tenant
      const existingRole = await this.prisma.role.findFirst({
        where: {
          name: data.name,
          tenant_id: data.tenantId || null,
        },
      });

      if (existingRole) {
        throw new BadRequestException(
          `Ya existe un rol con el nombre ${data.name}`,
        );
      }

      // Verificar que los permisos existan
      const permissions = await this.prisma.permission.findMany({
        where: {
          name: {
            in: data.permissions,
          },
        },
      });

      if (permissions.length !== data.permissions.length) {
        throw new BadRequestException('Algunos permisos no existen');
      }

      // Crear el rol con sus permisos
      return this.prisma.$transaction(async (tx) => {
        const role = await tx.role.create({
          data: {
            name: data.name,
            description: data.description,
            is_system: data.isSystem || false,
            tenant_id: data.tenantId,
          },
        });

        // Asociar permisos al rol
        for (const permission of permissions) {
          await tx.role_permission.create({
            data: {
              role_id: role.id,
              permission_id: permission.id,
            },
          });
        }

        return role;
      });
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException(`Error al crear el rol: ${error.message}`);
    }
  }

  async getRoles(tenantId?: string) {
    return this.prisma.role.findMany({
      where: {
        OR: [{ tenant_id: tenantId }, { is_system: true }],
        deleted: false,
      },
      include: {
        permissions: {
          include: {
            permission: true,
          },
        },
      },
    });
  }

  async getRoleById(id: string) {
    const role = await this.prisma.role.findUnique({
      where: { id },
      include: {
        permissions: {
          include: {
            permission: true,
          },
        },
      },
    });

    if (!role) {
      throw new NotFoundException(`Rol con ID ${id} no encontrado`);
    }

    return role;
  }

  async updateRole(id: string, data: UpdateRoleDto) {
    try {
      const role = await this.getRoleById(id);

      if (role.is_system) {
        throw new BadRequestException(
          'No se pueden modificar roles del sistema',
        );
      }

      return this.prisma.$transaction(async (tx) => {
        // Actualizar datos básicos del rol
        const updatedRole = await tx.role.update({
          where: { id },
          data: {
            name: data.name,
            description: data.description,
          },
        });

        // Si se proporcionan permisos, actualizar los permisos del rol
        if (data.permissions) {
          // Verificar que los permisos existan
          const permissions = await tx.permission.findMany({
            where: {
              name: {
                in: data.permissions,
              },
            },
          });

          if (permissions.length !== data.permissions.length) {
            throw new BadRequestException('Algunos permisos no existen');
          }

          // Eliminar permisos actuales
          await tx.role_permission.deleteMany({
            where: { role_id: id },
          });

          // Asociar nuevos permisos
          for (const permission of permissions) {
            await tx.role_permission.create({
              data: {
                role_id: id,
                permission_id: permission.id,
              },
            });
          }
        }

        return updatedRole;
      });
    } catch (error) {
      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Error al actualizar el rol: ${error.message}`,
      );
    }
  }

  async deleteRole(id: string) {
    try {
      const role = await this.getRoleById(id);

      if (role.is_system) {
        throw new BadRequestException(
          'No se pueden eliminar roles del sistema',
        );
      }

      // Verificar si hay usuarios con este rol
      const usersWithRole = await this.prisma.user_role.findMany({
        where: { role_id: id },
      });

      if (usersWithRole.length > 0) {
        throw new BadRequestException(
          'No se puede eliminar un rol asignado a usuarios',
        );
      }

      // Eliminar el rol y sus permisos asociados
      return this.prisma.$transaction(async (tx) => {
        // Eliminar permisos del rol
        await tx.role_permission.deleteMany({
          where: { role_id: id },
        });

        // Eliminar el rol
        return tx.role.delete({
          where: { id },
        });
      });
    } catch (error) {
      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Error al eliminar el rol: ${error.message}`,
      );
    }
  }

  async assignRoleToUser(userId: string, roleId: string) {
    try {
      // Verificar si el usuario existe
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new NotFoundException(`Usuario con ID ${userId} no encontrado`);
      }

      // Verificar si el rol existe
      const role = await this.getRoleById(roleId);

      // Verificar si el usuario ya tiene este rol
      const existingUserRole = await this.prisma.user_role.findFirst({
        where: {
          user_id: userId,
          role_id: roleId,
        },
      });

      if (existingUserRole) {
        throw new BadRequestException('El usuario ya tiene asignado este rol');
      }

      // Asignar rol al usuario
      return this.prisma.user_role.create({
        data: {
          user_id: userId,
          role_id: roleId,
        },
      });
    } catch (error) {
      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Error al asignar rol al usuario: ${error.message}`,
      );
    }
  }

  async removeRoleFromUser(userId: string, roleId: string) {
    try {
      // Verificar si la relación existe
      const userRole = await this.prisma.user_role.findFirst({
        where: {
          user_id: userId,
          role_id: roleId,
        },
      });

      if (!userRole) {
        throw new NotFoundException('El usuario no tiene asignado este rol');
      }

      // Eliminar la relación
      return this.prisma.user_role.delete({
        where: { id: userRole.id },
      });
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException(
        `Error al eliminar rol del usuario: ${error.message}`,
      );
    }
  }

  async getUserRoles(userId: string) {
    // Verificar si el usuario existe
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    });

    if (!user) {
      throw new NotFoundException(`Usuario con ID ${userId} no encontrado`);
    }

    // Obtener roles del usuario
    return this.prisma.user_role.findMany({
      where: { user_id: userId },
      include: {
        role: {
          include: {
            permissions: {
              include: {
                permission: true,
              },
            },
          },
        },
      },
    });
  }
}

================
File: src/catalogs/cat-cie-diez/cat-cie-diez.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { CatCieDiezController } from './cat-cie-diez.controller';
import { CatCieDiezService } from './cat-cie-diez.service';

describe('CatCieDiezController', () => {
  let controller: CatCieDiezController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CatCieDiezController],
      providers: [CatCieDiezService],
    }).compile();

    controller = module.get<CatCieDiezController>(CatCieDiezController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/catalogs/cat-cie-diez/cat-cie-diez.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common';
import { CatCieDiezService } from './cat-cie-diez.service';
import { CreateCatCieDiezDto } from './dto/create-cat-cie-diez.dto';
import { UpdateCatCieDiezDto } from './dto/update-cat-cie-diez.dto';
import { PaginationParams } from 'src/utils/pagination.helper';

@Controller('cat-cie-diez')
export class CatCieDiezController {
  constructor(private readonly catCieDiezService: CatCieDiezService) {}

  @Post()
  create(@Body() createCatCieDiezDto: CreateCatCieDiezDto) {
    return this.catCieDiezService.create(createCatCieDiezDto);
  }

  @Get()
  findAll(@Query() paginationParams: PaginationParams) {
    return this.catCieDiezService.findAll(paginationParams);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.catCieDiezService.findOne(+id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateCatCieDiezDto: UpdateCatCieDiezDto,
  ) {
    return this.catCieDiezService.update(+id, updateCatCieDiezDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.catCieDiezService.remove(+id);
  }
}

================
File: src/catalogs/cat-cie-diez/cat-cie-diez.module.ts
================
import { Module } from '@nestjs/common';
import { CatCieDiezService } from './cat-cie-diez.service';
import { CatCieDiezController } from './cat-cie-diez.controller';
import { PrismaService } from 'src/prisma/prisma.service';

@Module({
  controllers: [CatCieDiezController],
  providers: [CatCieDiezService, PrismaService],
})
export class CatCieDiezModule {}

================
File: src/catalogs/cat-cie-diez/cat-cie-diez.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { CatCieDiezService } from './cat-cie-diez.service';

describe('CatCieDiezService', () => {
  let service: CatCieDiezService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CatCieDiezService],
    }).compile();

    service = module.get<CatCieDiezService>(CatCieDiezService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/catalogs/cat-cie-diez/cat-cie-diez.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { CreateCatCieDiezDto } from './dto/create-cat-cie-diez.dto';
import { UpdateCatCieDiezDto } from './dto/update-cat-cie-diez.dto';
import { PrismaService } from 'src/prisma/prisma.service';
import { CatCieDiez } from './entities/cat-cie-diez.entity';
import {
  PaginationParams,
  parsePaginationAndSorting,
} from 'src/utils/pagination.helper';

@Injectable()
export class CatCieDiezService {
  constructor(private readonly prisma: PrismaService) {}
  async create(createCatCieDiezDto: CreateCatCieDiezDto): Promise<object> {
    try {
      const user = await this.prisma.category_cie_diez.create({
        data: { ...createCatCieDiezDto },
      });
      return { message: 'La categoría ha sido correctamente creada' };
    } catch (error) {
      return { message: `Error al crear la categoria ${error.message}` };
    }
  }

  async findAll(paginationParams: PaginationParams) {
    try {
      const { skip, take, orderBy, orderDirection } =
        parsePaginationAndSorting(paginationParams);

      const categories = await this.prisma.category_cie_diez.findMany({
        skip,
        take,
        orderBy: { [orderBy]: orderDirection },
      });
      return categories;
    } catch (error) {
      return { message: `Error al consultar las categorias ${error.message}` };
    }
  }

  async findOne(id: number) {
    try {
      const category = await this.prisma.category_cie_diez.findUnique({
        where: {
          id: id,
        },
      });
      if (!category) throw new NotFoundException('No existe la categoria');

      return category;
    } catch (error) {
      return { message: `Error al consultar la categoria ${error.message}` };
    }
  }

  async update(id: number, updateCatCieDiezDto: UpdateCatCieDiezDto) {
    try {
      const category = await this.prisma.category_cie_diez.update({
        where: { id: id },
        data: { ...updateCatCieDiezDto },
      });
      return { message: 'La categoría ha sido correctamente actualizada' };
    } catch (error) {
      return { message: `Error al actualizar la categoria ${error.message}` };
    }
  }

  async remove(id: number) {
    try {
      const category = await this.prisma.category_cie_diez.delete({
        where: { id: id },
      });
      return { message: 'La categoría ha sido correctamente eliminada' };
    } catch (error) {
      return { message: `Error al eliminar la categoria ${error.message}` };
    }
  }
}

================
File: src/catalogs/cat-cie-diez/dto/create-cat-cie-diez.dto.ts
================
import { IsString } from 'class-validator';

export class CreateCatCieDiezDto {
  /**
   * Category code
   * @example "A001"
   */
  @IsString()
  code: string;

  /**
   * Category description
   * @example "Fiebres tifoidea y paratifoidea"
   */
  @IsString()
  description: string;
}

================
File: src/catalogs/cat-cie-diez/dto/update-cat-cie-diez.dto.ts
================
import { PartialType } from '@nestjs/swagger';
import { CreateCatCieDiezDto } from './create-cat-cie-diez.dto';

export class UpdateCatCieDiezDto extends PartialType(CreateCatCieDiezDto) {}

================
File: src/catalogs/cat-cie-diez/entities/cat-cie-diez.entity.ts
================
export class CatCieDiez {
  id: number;
  code: string;
  description: string;
}

================
File: src/catalogs/cat-measure-unit/cat-measure-unit.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Query,
  BadRequestException,
  UseGuards,
} from '@nestjs/common';
import { CatMeasureUnitService } from './cat-measure-unit.service';
import { CreateCatMeasureUnitDto } from './dto/create-cat-measure-unit.dto';
import { RequirePermission } from '../../auth/decorators/require-permission.decorator';
import { Permission } from '../../auth/permissions/permission.enum';
import { PermissionGuard } from '../../auth/guards/permission.guard';
import { TenantAccessGuard } from '../../auth/guards/tenant-access.guard';
import { SuperAdminGuard } from '../../auth/guards/superadmin.guard';

@Controller('cat-measure-unit')
@UseGuards(TenantAccessGuard, PermissionGuard)
export class CatMeasureUnitController {
  constructor(private readonly catMeasureUnitService: CatMeasureUnitService) {}

  @Post()
  @UseGuards(SuperAdminGuard)
  @RequirePermission(Permission.MANAGE_CATALOGS)
  async create(@Body() createCatMeasureUnitDto: CreateCatMeasureUnitDto) {
    return this.catMeasureUnitService.create(createCatMeasureUnitDto);
  }

  @Get()
  @RequirePermission(Permission.VIEW_DOCTORS_LIST)
  async findAll(@Query('vitalSignId') vitalSignIdString?: string) {
    try {
      let vitalSignId: number | undefined;

      if (vitalSignIdString) {
        vitalSignId = parseInt(vitalSignIdString, 10);
        if (isNaN(vitalSignId)) {
          throw new BadRequestException(
            `ID de signo vital inválido: ${vitalSignIdString}`,
          );
        }
      }

      return this.catMeasureUnitService.findAll(vitalSignId);
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException('Error al obtener las unidades de medida');
    }
  }

  @Delete(':id')
  @UseGuards(SuperAdminGuard)
  @RequirePermission(Permission.MANAGE_CATALOGS)
  async remove(@Param('id') id: string) {
    const parsedId = parseInt(id, 10);
    if (isNaN(parsedId)) {
      throw new BadRequestException('ID inválido');
    }

    return this.catMeasureUnitService.remove(parsedId);
  }
}

================
File: src/catalogs/cat-measure-unit/cat-measure-unit.interface.ts
================
export interface CatMeasureUnit {
  id?: number;
  name: string;
  description: string;
  cat_vital_signs_id?: number;
}

================
File: src/catalogs/cat-measure-unit/cat-measure-unit.module.ts
================
import { Module } from '@nestjs/common';
import { CatMeasureUnitService } from './cat-measure-unit.service';
import { CatMeasureUnitController } from './cat-measure-unit.controller';
import { PrismaService } from '../../prisma/prisma.service';
import { GuardAuthModule } from 'src/auth/guard-auth.module';

@Module({
  imports: [GuardAuthModule],
  controllers: [CatMeasureUnitController],
  providers: [CatMeasureUnitService, PrismaService],
})
export class CatMeasureUnitModule {}

================
File: src/catalogs/cat-measure-unit/cat-measure-unit.service.ts
================
import {
  Injectable,
  BadRequestException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateCatMeasureUnitDto } from './dto/create-cat-measure-unit.dto';

@Injectable()
export class CatMeasureUnitService {
  constructor(private prisma: PrismaService) {}

  async create(data: CreateCatMeasureUnitDto) {
    try {
      // Check if vital sign exists
      const vitalSign = await this.prisma.cat_vital_signs.findUnique({
        where: { id: data.cat_vital_signs_id },
      });

      if (!vitalSign) {
        throw new BadRequestException('El signo vital asociado no existe');
      }

      // Check if measure unit with the same name already exists for this vital sign
      const existingMeasureUnit = await this.prisma.cat_measure_unit.findFirst({
        where: {
          name: data.name,
          cat_vital_signs_id: data.cat_vital_signs_id,
        },
      });

      if (existingMeasureUnit) {
        throw new BadRequestException(
          'Ya existe una unidad de medida con este nombre para este signo vital',
        );
      }

      // Create the measure unit
      return await this.prisma.cat_measure_unit.create({
        data: {
          name: data.name,
          description: data.description,
          cat_vital_signs_id: data.cat_vital_signs_id,
        },
      });
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException('Error al crear la unidad de medida');
    }
  }

  async findAll(vitalSignId?: number) {
    try {
      if (vitalSignId) {
        // Filter by vital sign ID
        return await this.prisma.cat_measure_unit.findMany({
          where: {
            cat_vital_signs_id: vitalSignId,
          },
          include: {
            cat_vital_signs: true,
          },
        });
      } else {
        // Return all measure units
        return await this.prisma.cat_measure_unit.findMany({
          include: {
            cat_vital_signs: true,
          },
        });
      }
    } catch {
      throw new BadRequestException('Error al obtener las unidades de medida');
    }
  }

  async remove(id: number) {
    try {
      // Check if measure unit exists
      const measureUnit = await this.prisma.cat_measure_unit.findUnique({
        where: { id },
      });

      if (!measureUnit) {
        throw new NotFoundException('Unidad de medida no encontrada');
      }

      // Delete the measure unit
      return await this.prisma.cat_measure_unit.delete({
        where: { id },
      });
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }
      throw new BadRequestException('Error al eliminar la unidad de medida');
    }
  }
}

================
File: src/catalogs/cat-measure-unit/dto/create-cat-measure-unit.dto.ts
================
import { IsString, IsNumber, IsOptional } from 'class-validator';

export class CreateCatMeasureUnitDto {
  /**
   * Measure unit name
   * @example "mmHg"
   */
  @IsString()
  name: string;

  /**
   * Measure unit description
   * @example "Milímetros de mercurio"
   */
  @IsString()
  description: string;

  /**
   * ID of the related vital sign
   * @example 1
   */
  @IsNumber()
  cat_vital_signs_id: number;
}

================
File: src/catalogs/cat-study-type/cat-study-type.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Put,
  Delete,
} from '@nestjs/common';
import { CatStudyTypeService } from './cat-study-type.service';
import { CatStudyType } from './cat-study-type.interface';

@Controller('cat-study-type')
export class CatStudyTypeController {
  constructor(private readonly catStudyTypeService: CatStudyTypeService) {}

  @Post()
  async create(@Body() data: CatStudyType): Promise<CatStudyType> {
    return this.catStudyTypeService.create(data);
  }

  @Get()
  async findAll(): Promise<CatStudyType[]> {
    return this.catStudyTypeService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: number): Promise<CatStudyType> {
    return this.catStudyTypeService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: number,
    @Body() data: CatStudyType,
  ): Promise<CatStudyType> {
    return this.catStudyTypeService.update(id, data);
  }

  @Delete(':id')
  async remove(@Param('id') id: number): Promise<CatStudyType> {
    return this.catStudyTypeService.remove(id);
  }
}

================
File: src/catalogs/cat-study-type/cat-study-type.interface.ts
================
export interface CatStudyType {
  id?: number;
  name: string;
}

================
File: src/catalogs/cat-study-type/cat-study-type.module.ts
================
import { Module } from '@nestjs/common';
import { CatStudyTypeService } from './cat-study-type.service';
import { CatStudyTypeController } from './cat-study-type.controller';
import { PrismaService } from '../../prisma/prisma.service'; // Adjust the path as necessary

@Module({
  imports: [],
  controllers: [CatStudyTypeController],
  providers: [CatStudyTypeService, PrismaService],
})
export class CatStudyTypeModule {}

================
File: src/catalogs/cat-study-type/cat-study-type.service.ts
================
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CatStudyType } from './cat-study-type.interface';

@Injectable()
export class CatStudyTypeService {
  constructor(private prisma: PrismaService) {}

  async create(data: CatStudyType): Promise<CatStudyType> {
    return this.prisma.cat_study_type.create({
      data,
    });
  }

  async findAll(): Promise<CatStudyType[]> {
    return this.prisma.cat_study_type.findMany();
  }

  async findOne(id: number): Promise<CatStudyType> {
    return this.prisma.cat_study_type.findUnique({
      where: { id: Number(id) },
    });
  }

  async update(id: number, data: CatStudyType): Promise<CatStudyType> {
    return this.prisma.cat_study_type.update({
      where: { id },
      data,
    });
  }

  async remove(id: number): Promise<CatStudyType> {
    return this.prisma.cat_study_type.delete({
      where: { id },
    });
  }
}

================
File: src/catalogs/cat-vital-signs/cat-vital-signs.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Query,
  BadRequestException,
  UseGuards,
} from '@nestjs/common';
import { CatVitalSignsService } from './cat-vital-signs.service';
import { CreateCatVitalSignsDto } from './dto/create-cat-vital-signs.dto';
import { RequirePermission } from '../../auth/decorators/require-permission.decorator';
import { Permission } from '../../auth/permissions/permission.enum';
import { PermissionGuard } from '../../auth/guards/permission.guard';
import { TenantAccessGuard } from '../../auth/guards/tenant-access.guard';
import { SuperAdminGuard } from '../../auth/guards/superadmin.guard';

@Controller('cat-vital-signs')
@UseGuards(TenantAccessGuard, PermissionGuard)
export class CatVitalSignsController {
  constructor(private readonly catVitalSignsService: CatVitalSignsService) {}

  @Post()
  @UseGuards(SuperAdminGuard)
  @RequirePermission(Permission.MANAGE_CATALOGS)
  async create(@Body() createCatVitalSignsDto: CreateCatVitalSignsDto) {
    return this.catVitalSignsService.create(createCatVitalSignsDto);
  }

  @Get()
  @RequirePermission(Permission.VIEW_DOCTORS_LIST)
  async findAll(@Query('specialtyIds') specialtyIdsString?: string) {
    try {
      let specialtyIds: number[] | undefined;

      if (specialtyIdsString) {
        specialtyIds = specialtyIdsString.split(',').map((id) => {
          const parsedId = parseInt(id.trim(), 10);
          if (isNaN(parsedId)) {
            throw new BadRequestException(`ID de especialidad inválido: ${id}`);
          }
          return parsedId;
        });
      }

      return this.catVitalSignsService.findAll(specialtyIds);
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException('Error al obtener los signos vitales');
    }
  }

  @Delete(':id')
  @UseGuards(SuperAdminGuard)
  @RequirePermission(Permission.MANAGE_CATALOGS)
  async remove(@Param('id') id: string) {
    const parsedId = parseInt(id, 10);
    if (isNaN(parsedId)) {
      throw new BadRequestException('ID inválido');
    }

    return this.catVitalSignsService.remove(parsedId);
  }
}

================
File: src/catalogs/cat-vital-signs/cat-vital-signs.interface.ts
================
export interface CatVitalSigns {
  id?: number;
  name: string;
  category: string;
  specialties?: number[];
}

================
File: src/catalogs/cat-vital-signs/cat-vital-signs.module.ts
================
import { Module } from '@nestjs/common';
import { CatVitalSignsService } from './cat-vital-signs.service';
import { CatVitalSignsController } from './cat-vital-signs.controller';
import { PrismaService } from '../../prisma/prisma.service';
import { GuardAuthModule } from 'src/auth/guard-auth.module';

@Module({
  imports: [GuardAuthModule],
  controllers: [CatVitalSignsController],
  providers: [CatVitalSignsService, PrismaService],
})
export class CatVitalSignsModule {}

================
File: src/catalogs/cat-vital-signs/cat-vital-signs.service.ts
================
import {
  Injectable,
  BadRequestException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateCatVitalSignsDto } from './dto/create-cat-vital-signs.dto';

@Injectable()
export class CatVitalSignsService {
  constructor(private prisma: PrismaService) {}

  async create(data: CreateCatVitalSignsDto) {
    try {
      const existingVitalSign = await this.prisma.cat_vital_signs.findFirst({
        where: { name: data.name },
      });

      if (existingVitalSign) {
        throw new BadRequestException(
          'Ya existe un signo vital con este nombre',
        );
      }

      return await this.prisma.cat_vital_signs.create({
        data: {
          name: data.name,
          category: data.category,
          specialties: {
            connect: data.specialties.map((id) => ({ id })),
          },
        },
        include: {
          specialties: true,
        },
      });
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException('Error al crear el signo vital');
    }
  }

  async findAll(specialtyIds?: number[]) {
    try {
      const filterSpecialtyIds = specialtyIds?.length ? specialtyIds : [1];

      return await this.prisma.cat_vital_signs.findMany({
        where: {
          specialties: {
            some: {
              id: {
                in: filterSpecialtyIds,
              },
            },
          },
        },
        include: {
          specialties: true,
          cat_vital_sign_measure: true,
        },
      });
    } catch {
      throw new BadRequestException('Error al obtener los signos vitales');
    }
  }

  async remove(id: number) {
    try {
      const vitalSign = await this.prisma.cat_vital_signs.findUnique({
        where: { id },
        include: {
          vital_signs: true,
        },
      });

      if (!vitalSign) {
        throw new NotFoundException('Signo vital no encontrado');
      }

      if (vitalSign.vital_signs.length > 0) {
        throw new BadRequestException(
          'No se puede eliminar un signo vital que está en uso',
        );
      }

      return await this.prisma.cat_vital_signs.delete({
        where: { id },
        include: {
          specialties: true,
        },
      });
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }
      throw new BadRequestException('Error al eliminar el signo vital');
    }
  }
}

================
File: src/catalogs/cat-vital-signs/dto/create-cat-vital-signs.dto.ts
================
import { IsString, IsArray, IsNumber, ArrayMinSize } from 'class-validator';

export class CreateCatVitalSignsDto {
  @IsString()
  name: string;

  @IsString()
  category: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @ArrayMinSize(1)
  specialties: number[];
}

================
File: src/catalogs/subcat-cie-diez/dto/create-subcat-cie-diez.dto.ts
================
import { IsNotEmpty, IsNumber, IsString } from 'class-validator';

export class CreateSubcatCieDiezDto {
  @IsString()
  code: string;

  @IsString()
  description: string;

  @IsNumber()
  @IsNotEmpty()
  categoryId: number;
}

================
File: src/catalogs/subcat-cie-diez/dto/update-subcat-cie-diez.dto.ts
================
import { PartialType } from '@nestjs/swagger';
import { CreateSubcatCieDiezDto } from './create-subcat-cie-diez.dto';

export class UpdateSubcatCieDiezDto extends PartialType(
  CreateSubcatCieDiezDto,
) {}

================
File: src/catalogs/subcat-cie-diez/entities/subcat-cie-diez.entity.ts
================
export class SubcatCieDiez {}

================
File: src/catalogs/subcat-cie-diez/subcat-cie-diez.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { SubcatCieDiezController } from './subcat-cie-diez.controller';
import { SubcatCieDiezService } from './subcat-cie-diez.service';

describe('SubcatCieDiezController', () => {
  let controller: SubcatCieDiezController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [SubcatCieDiezController],
      providers: [SubcatCieDiezService],
    }).compile();

    controller = module.get<SubcatCieDiezController>(SubcatCieDiezController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/catalogs/subcat-cie-diez/subcat-cie-diez.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common';
import { SubcatCieDiezService } from './subcat-cie-diez.service';
import { CreateSubcatCieDiezDto } from './dto/create-subcat-cie-diez.dto';
import { UpdateSubcatCieDiezDto } from './dto/update-subcat-cie-diez.dto';
import { PaginationParams } from 'src/utils/pagination.helper';

@Controller('subcat-cie-diez')
export class SubcatCieDiezController {
  constructor(private readonly subcatCieDiezService: SubcatCieDiezService) {}

  @Post()
  create(@Body() createSubcatCieDiezDto: CreateSubcatCieDiezDto) {
    return this.subcatCieDiezService.create(createSubcatCieDiezDto);
  }

  @Get()
  findAll(@Query() paginationParams: PaginationParams) {
    return this.subcatCieDiezService.findAll(paginationParams);
  }

  @Get('search')
  search(@Query('searchWord') searchWord: string) {
    return this.subcatCieDiezService.search(searchWord);
  }

  @Get('category/:id')
  findAllCategories(
    @Param('id') id: number,
    @Query() paginationParams: PaginationParams,
  ) {
    return this.subcatCieDiezService.findAllCategories(id, paginationParams);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.subcatCieDiezService.findOne(+id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateSubcatCieDiezDto: UpdateSubcatCieDiezDto,
  ) {
    return this.subcatCieDiezService.update(+id, updateSubcatCieDiezDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.subcatCieDiezService.remove(+id);
  }
}

================
File: src/catalogs/subcat-cie-diez/subcat-cie-diez.module.ts
================
import { Module } from '@nestjs/common';
import { SubcatCieDiezService } from './subcat-cie-diez.service';
import { SubcatCieDiezController } from './subcat-cie-diez.controller';
import { PrismaService } from 'src/prisma/prisma.service';

@Module({
  controllers: [SubcatCieDiezController],
  providers: [SubcatCieDiezService, PrismaService],
})
export class SubcatCieDiezModule {}

================
File: src/catalogs/subcat-cie-diez/subcat-cie-diez.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { SubcatCieDiezService } from './subcat-cie-diez.service';

describe('SubcatCieDiezService', () => {
  let service: SubcatCieDiezService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SubcatCieDiezService],
    }).compile();

    service = module.get<SubcatCieDiezService>(SubcatCieDiezService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/catalogs/subcat-cie-diez/subcat-cie-diez.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { CreateSubcatCieDiezDto } from './dto/create-subcat-cie-diez.dto';
import { UpdateSubcatCieDiezDto } from './dto/update-subcat-cie-diez.dto';
import { PrismaService } from 'src/prisma/prisma.service';
import {
  PaginationParams,
  parsePaginationAndSorting,
} from 'src/utils/pagination.helper';

@Injectable()
export class SubcatCieDiezService {
  constructor(private readonly prisma: PrismaService) {}
  async create(createSubcatCieDiezDto: CreateSubcatCieDiezDto) {
    try {
      const category = await this.prisma.category_cie_diez.findUnique({
        where: { id: createSubcatCieDiezDto.categoryId },
      });

      if (!category)
        throw new NotFoundException('No se encuentra la categoria');

      const subCat = await this.prisma.subcategories_cie_diez.create({
        data: {
          ...createSubcatCieDiezDto,
        },
      });

      if (!subCat) throw new Error('No se ha podido generar la sub categoria');

      return { message: 'La sub categoría ha sido correctamente creada' };
    } catch (error) {
      return { message: `Error al crear la sub categoria ${error.message}` };
    }
  }

  async search(searchWord: string) {
    try {
      const subcat = await this.prisma.subcategories_cie_diez.findMany({
        where: {
          OR: [
            {
              code: {
                contains: searchWord,
                mode: 'insensitive',
              },
            },
            {
              description: {
                contains: searchWord,
                mode: 'insensitive',
              },
            },
          ],
        },
      });

      if (!subcat)
        throw new NotFoundException({ message: 'No existe la sub categoria' });

      return subcat;
    } catch (error) {
      console.log(error);
      return {
        message: `Error al consultar las sub categorias ${error.message}`,
      };
    }
  }

  async findAll(paginationParams: PaginationParams) {
    try {
      const { skip, take, orderBy, orderDirection } =
        parsePaginationAndSorting(paginationParams);

      const subcategories = await this.prisma.subcategories_cie_diez.findMany({
        skip,
        take,
        orderBy: { [orderBy]: orderDirection },
      });
      return subcategories;
    } catch (error) {
      return {
        message: `Error al consultar las sub categorias ${error.message}`,
      };
    }
  }

  async findOne(id: number) {
    try {
      const subcategory = await this.prisma.subcategories_cie_diez.findUnique({
        where: { id: id },
      });
      if (!subcategory)
        throw new NotFoundException('No se encontró la sub categoria');
      return subcategory;
    } catch (error) {
      return {
        message: `Error al consultar la sub categoria ${error.message}`,
      };
    }
  }

  async update(id: number, updateSubcatCieDiezDto: UpdateSubcatCieDiezDto) {
    try {
      const subcategory = await this.prisma.subcategories_cie_diez.update({
        where: { id: id },
        data: { ...updateSubcatCieDiezDto },
      });
      return { message: 'La categoria ha sido correctamente actualizada' };
    } catch (error) {
      return {
        message: `Error al actualizar la sub categoria ${error.message}`,
      };
    }
  }

  async remove(id: number) {
    try {
      const subcategory = this.prisma.subcategories_cie_diez.delete({
        where: { id: id },
      });
      if (!subcategory)
        throw new NotFoundException('No se encontró la subcategoria');
      return { message: 'La sub categoría ha sido eliminada' };
    } catch (error) {
      return { message: `Error al eliminar la sub categoria ${error.message}` };
    }
  }

  async findAllCategories(id: number, paginationParams: PaginationParams) {
    try {
      const { skip, take, orderBy, orderDirection } =
        parsePaginationAndSorting(paginationParams);

      const subcategories = await this.prisma.subcategories_cie_diez.findMany({
        where: { categoryId: +id },
        skip,
        take,
        orderBy: { [orderBy]: orderDirection },
      });
      return subcategories;
    } catch (error) {
      return { message: `Error al consultar las categorias ${error.message}` };
    }
  }
}

================
File: src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { BadRequestException, ValidationPipe } from '@nestjs/common';
import { config } from 'dotenv';

config({ path: '.env' });

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors({
    origin: '*', // URL del frontend
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE', // Métodos permitidos
    credentials: true, // Si estás usando cookies o autenticación basada en sesión
  });

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      exceptionFactory: (errors) => {
        const cleanErrors = errors.map((err) => {
          return {
            property: err.property,
            constraints: err.constraints,
            children: err.children?.map((child) => ({
              property: child.property,
              constraints: child.constraints,
            })),
          };
        });
        console.log('Errores de validación detallados:', cleanErrors); // 👈 Depuración
        return new BadRequestException({
          alert: 'Se han detectado los siguientes errores en la petición: ',
          errors: cleanErrors,
        });
      },
    }),
  );

  const swaggerConfig = new DocumentBuilder()
    .setTitle('SEGIMED')
    .setDescription(
      'Manage your organization with SEGIMED, your medical partner.',
    )
    .setVersion('1.0')
    .addBearerAuth()
    .build();

  const document = SwaggerModule.createDocument(app, swaggerConfig);

  SwaggerModule.setup('api', app, document);

  await app.listen(process.env.PORT ?? 3000);
}

bootstrap();

================
File: src/management/auth/auth.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';

describe('AuthController', () => {
  let controller: AuthController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [AuthService],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/management/auth/auth.controller.ts
================
import { Controller, Post, Body, Req } from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateAuthDto } from './dto/create-auth.dto';
import { ApiTags } from '@nestjs/swagger';
import {
  CreateUserDto,
  GoogleUserDto,
} from 'src/management/user/dto/create-user.dto';
import { RequestPasswordDto, ResetPasswordDto } from './dto/password-auth.dto';
import { Request } from 'express';

@ApiTags('Auth')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  register(@Body() createUserDto: CreateUserDto) {
    return this.authService.create(createUserDto);
  }
  @Post()
  login(@Body() createAuthDto: CreateAuthDto) {
    return this.authService.login(createAuthDto);
  }

  @Post('google')
  googleLogin(@Body() GoogleUserDto: GoogleUserDto) {
    return this.authService.googleLogin(GoogleUserDto);
  }

  @Post('request-password')
  requestPasswordReset(
    @Body() RequestPasswordDto: RequestPasswordDto,
    @Req() req: Request,
  ): Promise<object> {
    return this.authService.requestPasswordReset(RequestPasswordDto, req);
  }

  @Post('reset-password')
  resetPassword(@Body() ResetPasswordDto: ResetPasswordDto): Promise<object> {
    return this.authService.resetPassword(
      ResetPasswordDto.token,
      ResetPasswordDto.password,
    );
  }

  @Post('send-otp')
  async sendVerificationCodePhone(
    @Body('user_id') user_id: string,
    @Body('phone_prefix') phone_prefix: string,
    @Body('phone') phone: string,
  ): Promise<object> {
    return this.authService.sendVerificationCodePhone(
      user_id,
      phone_prefix,
      phone,
    );
  }

  @Post('verify-otp')
  async verifyPhoneCode(
    @Body('user_id') user_id: string,
    @Body('code') code: string,
  ): Promise<object> {
    return this.authService.verifyPhoneCode(user_id, code);
  }
}

================
File: src/management/auth/auth.module.ts
================
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { PrismaService } from 'src/prisma/prisma.service';

@Module({
  controllers: [AuthController],
  providers: [AuthService, PrismaService],
})
export class AuthModule {}

================
File: src/management/auth/auth.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AuthService],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/management/auth/auth.service.ts
================
import { BadRequestException, Injectable } from '@nestjs/common';
import { CreateAuthDto } from './dto/create-auth.dto';
import { PrismaService } from 'src/prisma/prisma.service';
import { AuthHelper } from 'src/utils/auth.helper';
import {
  CreateUserDto,
  GoogleUserDto,
} from 'src/management/user/dto/create-user.dto';
import { RequestPasswordDto } from './dto/password-auth.dto';
import { EmailService } from 'src/services/email/email.service';
import { Request } from 'express';
import { recoverPasswordHtml } from 'src/services/email/templates/recoverPasswordHtml';
import { ConfigService } from '@nestjs/config';
import welcomeEmailHtml from 'src/services/email/templates/welcomeEmailHtml';
import { TwilioService } from 'src/services/twilio/twilio.service';

@Injectable()
export class AuthService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
    private readonly emailService: EmailService,
    private readonly otpService: TwilioService,
  ) {}
  async create(data: CreateUserDto): Promise<object> {
    try {
      const saltRounds = parseInt(
        this.configService.get<string>('BCRYPT_SALT_ROUNDS'),
      );
      data.password = await AuthHelper.hashPassword(data.password, saltRounds);

      const user = await this.prisma.user.create({
        data: data,
      });

      const htmlContent = welcomeEmailHtml(data.name);
      await this.emailService.sendMail(
        data.email,
        htmlContent,
        'Bienvenido a Segimed',
      );
      return {
        id: user.id,
        name: user.name,
        last_name: user.last_name,
      };
    } catch (error) {
      if (error.code === 'P2002') {
        throw new BadRequestException(
          'El correo electrónico ya está registrado.',
        );
      }
      console.log(error);
      throw new BadRequestException('No se pudo crear el usuario.');
    }
  }
  async login(createAuthDto: CreateAuthDto): Promise<object> {
    try {
      const user = await this.prisma.user.findUnique({
        where: { email: createAuthDto.email },
      });

      if (!user) {
        throw new BadRequestException('El email no está registrado');
      }

      const isPasswordValid = await AuthHelper.comparePasswords(
        createAuthDto.password,
        user.password,
      );

      if (!isPasswordValid) {
        throw new BadRequestException('La contraseña es incorrecta');
      }
      const jwtPayload = {
        email: user.email,
        id: user.id,
        name: user.name,
        last_name: user.last_name,
        tenant_id: user.tenant_id || '',
        role: user.role,
        image: user.image,
      };
      const jwt = AuthHelper.generateToken(jwtPayload);

      return { message: 'Login exitoso', jwt: jwt, user: jwtPayload };
    } catch (error) {
      console.log(error);
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new Error('Error al procesar la solicitud de login');
    }
  }

  async googleLogin(GoogleUserDto: GoogleUserDto): Promise<object> {
    try {
      let user = await this.prisma.user.findUnique({
        where: { email: GoogleUserDto.email },
      });

      if (!user) {
        user = await this.prisma.user.create({
          data: {
            email: GoogleUserDto.email,
            name: GoogleUserDto.name ?? '',
            image: GoogleUserDto.image ?? '',
            tenant_id: null,
            password: '',
          },
        });
      }

      if (!user) {
        throw new Error('Error al crear el usuario o el usuario no existe');
      }

      const jwtPayload = {
        id: user.id,
        email: user.email,
        name: user.name,
        image: user.image,
        tenant_id: user.tenant_id,
        role: user.role,
      };
      const token = AuthHelper.generateToken(jwtPayload);

      return {
        message: 'Login exitoso',
        token: token,
        user: jwtPayload,
      };
    } catch (error) {
      console.log(error);
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new Error('Error al procesar la solicitud de Google Login');
    }
  }

  async requestPasswordReset(
    RequestPasswordDto: RequestPasswordDto,
    req: Request,
  ): Promise<object> {
    try {
      const user = await this.prisma.user.findUnique({
        where: { email: RequestPasswordDto.email },
      });

      if (!user) {
        throw new BadRequestException('El email no está registrado');
      }
      const origin =
        req.headers.origin || req.protocol + '://' + req.headers.host;

      const jwtPayload = {
        email: user.email,
      };

      const token = AuthHelper.generateToken(jwtPayload, '1h');

      await this.prisma.password_reset.create({
        data: {
          email: user.email,
          token: token,
        },
      });

      const resetUrl = `${origin}/reset-password?token=${token}`;

      this.emailService.sendMail(
        RequestPasswordDto.email,
        recoverPasswordHtml(resetUrl),
        'Recuperar contraseña',
      );

      return {
        message:
          'Se ha enviado un correo electrónico para restablecer la contraseña',
      };
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new Error(
        'Error al procesar la solicitud de restablecimiento de contraseña',
      );
    }
  }

  async resetPassword(token: string, password: string): Promise<object> {
    try {
      const jwtVerification = AuthHelper.verifyToken(token);
      if (!jwtVerification || typeof jwtVerification === 'string') {
        throw new BadRequestException('El token no es válido');
      }
      const validToken = await this.prisma.password_reset.findUnique({
        where: { token: token, email: jwtVerification.email },
      });
      if (!validToken) {
        throw new BadRequestException('El token no es válido');
      }
      const saltRounds = parseInt(
        this.configService.get<string>('BCRYPT_SALT_ROUNDS'),
      );
      const hashPassword = await AuthHelper.hashPassword(password, saltRounds);
      await this.prisma.user.update({
        where: { email: jwtVerification.email },
        data: { password: hashPassword },
      });
      return { message: 'Contraseña restablecida con éxito.' };
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException('El token no es válido o ha expirado.');
    }
  }

  async sendVerificationCodePhone(
    user_id: string,
    phone_prefix: string,
    phone: string,
  ): Promise<object> {
    try {
      const verification_code = this.otpService.generateOtp();
      const phoneNumber = phone_prefix + phone;
      const code_expires_at = new Date(Date.now() + 5 * 60 * 1000);

      await this.prisma.$transaction(async (transaction) => {
        await transaction.otp_code.upsert({
          where: { id: user_id },
          create: {
            id: user_id,
            code: verification_code,
            code_expires_at: code_expires_at,
          },
          update: {
            code: verification_code,
            code_expires_at: code_expires_at,
          },
        });

        await transaction.user.update({
          where: { id: user_id },
          data: {
            phone_prefix,
            phone,
          },
        });

        await this.otpService.sendOtp(phoneNumber, verification_code);
      });

      return { message: 'Código de verificación enviado.' };
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      console.log(error);
      throw new BadRequestException(
        'Error al enviar el código de verificación.',
      );
    }
  }

  async verifyPhoneCode(user_id: string, code: string): Promise<object> {
    try {
      const user = await this.prisma.user.findUnique({
        where: { id: user_id },
      });
      const otp_exists = await this.prisma.otp_code.findUnique({
        where: {
          id: user_id,
        },
      });
      if (!user) {
        throw new BadRequestException('El usuario no existe');
      }
      if (!otp_exists) {
        throw new BadRequestException(
          'El usuario no tiene un código de verificación',
        );
      }
      if (otp_exists.code !== code) {
        throw new BadRequestException(
          'El código de verificación es incorrecto',
        );
      }
      if (otp_exists.code_expires_at < new Date()) {
        throw new BadRequestException('El código de verificación ha expirado');
      }
      await this.prisma.user.update({
        where: { id: user_id },
        data: {
          is_phone_verified: true,
        },
      });
      return {
        message: 'Número de teléfono verificado.',
      };
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      console.log(error);
      throw new BadRequestException(
        'Error al verificar el código de verificación.',
      );
    }
  }
}

================
File: src/management/auth/dto/create-auth.dto.ts
================
import { PickType } from '@nestjs/swagger';
import { CreateUserDto } from 'src/management/user/dto/create-user.dto';

export class CreateAuthDto extends PickType(CreateUserDto, [
  'email',
  'password',
]) {}

================
File: src/management/auth/dto/password-auth.dto.ts
================
import { IsEmail, IsNotEmpty, IsStrongPassword } from 'class-validator';

export class RequestPasswordDto {
  @IsEmail({}, { message: 'El correo electrónico no tiene un formato válido.' })
  email: string;
}

export class ResetPasswordDto {
  @IsNotEmpty({ message: 'La contraseña es obligatoria.' })
  @IsStrongPassword(
    {
      minLength: 8,
      minNumbers: 1,
      minLowercase: 1,
      minUppercase: 1,
      minSymbols: 1,
    },
    {
      message:
        'La contraseña debe tener al menos 8 caracteres, incluyendo 1 número, 1 letra minúscula, 1 letra mayúscula y 1 símbolo.',
    },
  )
  password: string;

  @IsNotEmpty({ message: 'El token es obligatorio.' })
  token: string;
}

================
File: src/management/auth/dto/update-auth.dto.ts
================
import { PartialType } from '@nestjs/swagger';
import { CreateAuthDto } from './create-auth.dto';

export class UpdateAuthDto extends PartialType(CreateAuthDto) {}

================
File: src/management/auth/entities/auth.entity.ts
================
export class Auth {}

================
File: src/management/patient/dto/create-patient.dto.ts
================
import { IsOptional, IsString, Length } from 'class-validator';

export class CreatePatientDto {
  @IsString({ message: 'La dirección debe ser un texto válido.' })
  @Length(3, 50, {
    message: 'La dirección debe tener entre 3 y 50 caracteres.',
  })
  @IsOptional()
  direction?: string;

  @IsString({ message: 'El país debe ser un texto válido.' })
  @Length(3, 50, { message: 'El país debe tener entre 3 y 50 caracteres.' })
  country: string;

  @IsString({ message: 'La provincia debe ser un texto válido.' })
  @Length(3, 50, {
    message: 'La provincia debe tener entre 3 y 50 caracteres.',
  })
  province: string;

  @IsString({ message: 'La ciudad debe ser un texto válido.' })
  @Length(3, 50, { message: 'La ciudad debe tener entre 3 y 50 caracteres.' })
  city: string;

  @IsString({ message: 'El código postal debe ser un texto válido.' })
  @Length(3, 50, {
    message: 'El código postal debe tener entre 3 y 50 caracteres.',
  })
  postal_code: string;

  @IsString({ message: 'El número de dirección debe ser un texto válido.' })
  @Length(3, 50, {
    message: 'El número de dirección debe tener entre 3 y 50 caracteres.',
  })
  @IsOptional()
  direction_number?: string;

  @IsString({ message: 'El apartamento debe ser un texto válido.' })
  @Length(1, 50, {
    message: 'El apartamento debe tener entre 3 y 50 caracteres.',
  })
  @IsOptional()
  apartment?: string;

  @IsString({ message: 'El número de seguro médico debe ser un texto válido.' })
  @Length(3, 50, {
    message: 'El número de seguro médico debe tener entre 3 y 50 caracteres.',
  })
  @IsOptional()
  health_care_number?: string;
}

================
File: src/management/patient/dto/get-patient.dto.ts
================
export class GetPatientsDto {
  id: string;
  name: string;
  last_name: string;
  image: string;
  birth_date: Date;
  gender: string;
  email: string;
  phone: string;
  prefix: string;
}

export class GetPatientDto {
  id: string;
  name: string;
  last_name: string;
  image: string;
  birth_date: Date;
  email: string;
  notes: string;
}

================
File: src/management/patient/dto/medical-patient.dto.ts
================
import { Type } from 'class-transformer';
import { IsNotEmpty, ValidateNested } from 'class-validator';

import { CreatePatientDto } from './create-patient.dto';
import { BaseUserDto } from 'src/management/user/dto/create-user.dto';

export class MedicalPatientDto {
  @ValidateNested()
  @Type(() => BaseUserDto)
  @IsNotEmpty({ message: 'El objeto user no puede estar vacío' })
  user: Omit<BaseUserDto, 'role' | 'password'>;

  @ValidateNested()
  @Type(() => CreatePatientDto)
  @IsNotEmpty({ message: 'El objeto patient no puede estar vacío' })
  patient: CreatePatientDto;
}

================
File: src/management/patient/dto/update-patient.dto.ts
================
import { PartialType } from '@nestjs/swagger';
import { CreatePatientDto } from './create-patient.dto';

export class UpdatePatientDto extends PartialType(CreatePatientDto) {}

================
File: src/management/patient/entities/patient.interface.ts
================
export interface Patient {
  id?: string;
  direction?: string;
  country?: string;
  province?: string;
  city?: string;
  postal_code?: string;
  direction_number?: string;
  apparment?: string;
  health_care_number?: string;
  userId?: string;
  appointments?: any[];
  medical_events?: any[];
}

================
File: src/management/patient/patient.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { PatientController } from './patient.controller';
import { PatientService } from './patient.service';

describe('PatientController', () => {
  let controller: PatientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [PatientController],
      providers: [PatientService],
    }).compile();

    controller = module.get<PatientController>(PatientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/management/patient/patient.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Req,
  Query,
} from '@nestjs/common';
import { PatientService } from './patient.service';
import { UpdatePatientDto } from './dto/update-patient.dto';

import { MedicalPatientDto } from './dto/medical-patient.dto';
import { Request } from 'express';
import { PaginationParams } from 'src/utils/pagination.helper';
/* import { MedicalPatientDto } from './dto/medical-patient.dto';
 */
@Controller('patient')
export class PatientController {
  constructor(private readonly patientService: PatientService) {}

  @Post()
  create(@Body() medicalPatientDto: MedicalPatientDto): Promise<object> {
    return this.patientService.create(medicalPatientDto);
  }

  @Get()
  findAll(@Req() req: Request, @Query() pagination: PaginationParams) {
    const tenant_id = req['tenant_id'];
    return this.patientService.findAll(tenant_id, pagination);
  }

  @Get(':id')
  findOne(@Param('id') id: string, @Req() req: Request) {
    const tenant_id = req['tenant_id'];
    return this.patientService.findOne(id, tenant_id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatePatientDto: UpdatePatientDto) {
    return this.patientService.update(id, updatePatientDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.patientService.remove(id);
  }
}

================
File: src/management/patient/patient.module.ts
================
import { Module } from '@nestjs/common';
import { PatientService } from './patient.service';
import { PatientController } from './patient.controller';
import { PrismaService } from 'src/prisma/prisma.service';
import { UserService } from 'src/management/user/user.service';

@Module({
  controllers: [PatientController],
  providers: [PatientService, PrismaService, UserService],
})
export class PatientModule {}

================
File: src/management/patient/patient.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { PatientService } from './patient.service';

describe('PatientService', () => {
  let service: PatientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PatientService],
    }).compile();

    service = module.get<PatientService>(PatientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/management/patient/patient.service.ts
================
import { BadRequestException, Injectable } from '@nestjs/common';
import { UpdatePatientDto } from './dto/update-patient.dto';
import { PrismaService } from 'src/prisma/prisma.service';
import { EmailService } from 'src/services/email/email.service';
import { MedicalPatientDto } from './dto/medical-patient.dto';
import { sendCredentialsHtml } from 'src/services/email/templates/credentialsHtml';
import { GetPatientDto, GetPatientsDto } from './dto/get-patient.dto';
import {
  PaginationParams,
  parsePaginationAndSorting,
} from 'src/utils/pagination.helper';
/* import { MedicalPatientDto } from './dto/medical-patient.dto';
 */
@Injectable()
export class PatientService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly emailService: EmailService,
  ) {}

  async create(medicalPatientDto: MedicalPatientDto): Promise<object> {
    try {
      const { patient, user } = medicalPatientDto;

      const newPassword = `${user.name.charAt(0).toUpperCase() + user.name.slice(1) + '.' + user.dni}`;
      const existingUserWithSameTenant = await this.prisma.user.findFirst({
        where: {
          email: user.email,
        },
        include: {
          patient: {
            include: {
              patient_tenant: true,
            },
          },
        },
      });
      if (
        existingUserWithSameTenant.patient.patient_tenant.includes(
          global.tenant_id,
        )
      ) {
        throw new BadRequestException(
          'El usuario ya existe para esta organización',
        );
      }

      return await this.prisma.$transaction(async (transaction) => {
        const newUser = await transaction.user.create({
          data: {
            ...user,
            role: 'patient',
            password: newPassword,
          },
        });

        const newPatient = await transaction.patient.create({
          data: {
            ...patient,
            user_id: newUser.id,
          },
        });

        await transaction.patient_tenant.create({
          data: {
            patient_id: newPatient.id,
            tenant_id: global.tenant_id,
          },
        });

        await this.emailService.sendMail(
          user.email,
          sendCredentialsHtml(user.email, newPassword),
          'Credenciales Segimed',
        );

        return { message: 'Paciente creado exitosamente' };
      });
    } catch (error) {
      throw new BadRequestException(
        'Error al crear el paciente: ' + error.message,
      );
    }
  }

  async findAll(
    tenant_id: string,
    pagination: PaginationParams,
  ): Promise<GetPatientsDto[]> {
    try {
      const { skip, take, orderBy, orderDirection } =
        parsePaginationAndSorting(pagination);
      const users = await this.prisma.user.findMany({
        where: {
          role: 'patient',
          tenant_id,
        },
        skip,
        take,
        orderBy: { [orderBy]: orderDirection },
      });
      if (users.length === 0) {
        throw new BadRequestException('No hay pacientes que mostrar.');
      }
      return users.map((user) => {
        return {
          id: user.id,
          name: user.name,
          last_name: user.last_name,
          image: user.image,
          birth_date: user.birth_date,
          gender: user.gender,
          email: user.email,
          phone: user.phone,
          prefix: user.phone_prefix,
        };
      });
    } catch (error) {
      console.error('Error en findAll:', error);
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException('Error al obtener los pacientes');
    }
  }

  async findOne(id: string, tenant_id: string): Promise<GetPatientDto> {
    try {
      const user = await this.prisma.user.findUnique({
        where: { id, tenant_id },
        include: { patient: true },
      });

      if (!user) {
        throw new BadRequestException('Paciente no encontrado');
      }

      return {
        id: user.id,
        name: user.name,
        last_name: user.last_name,
        image: user.image,
        birth_date: user.birth_date,
        email: user.email,
        notes: user.patient.notes,
      };
    } catch (error) {
      console.error('Error en findOne:', error);
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException('Error al obtener el paciente');
    }
  }

  async update(id: string, updatePatientDto: UpdatePatientDto) {
    try {
      const { ...filteredDto } = updatePatientDto;
      const newPatient = await this.prisma.patient.update({
        where: { id: id },
        data: filteredDto as any,
      });
      return newPatient;
    } catch (error) {
      console.error('Error en update:', error);
      if (error?.code === 'P2025') {
        throw new BadRequestException('Paciente no encontrado');
      }
      throw new BadRequestException('Error al actualizar el paciente');
    }
  }

  async remove(id: string) {
    try {
      return await this.prisma.patient.delete({ where: { id: id } });
    } catch (error) {
      console.error('Error en remove:', error);
      if (error?.code === 'P2025') {
        throw new BadRequestException('Paciente no encontrado');
      }
      throw new BadRequestException('Error al eliminar el paciente');
    }
  }
}

================
File: src/management/suscription/paypal/paypal.controller.ts
================
/* import { Controller, Post, Body, Param } from '@nestjs/common';
import { PayPalService } from './services/paypal.service';
import { TransactionService } from './services/transaction.service';

@Controller('paypal')
export class PayPalController {
  constructor(
    private readonly payPalService: PayPalService,
    private readonly transactionService: TransactionService,
  ) {}

  @Post('capture-order/:orderId')
  async captureOrder(
    @Param('orderId') orderId: string,
    @Body() body: { userId: string },
  ) {
    const captureResult = await this.payPalService.captureOrder(orderId);

    // Guardar la transacción en la base de datos
    await this.transactionService.createTransaction({
      orderId,
      status: captureResult.status,
      amount: parseFloat(captureResult.purchase_units[0].amount.value),
      currency: captureResult.purchase_units[0].amount.currency_code,
      userId: body.userId,
      tenant_id: body.userId,
    });

    return captureResult;
  }
}
 */

================
File: src/management/suscription/paypal/paypal.module.ts
================
/* import { Module } from '@nestjs/common';
import { PayPalService } from './services/paypal.service';
import { PayPalController } from './paypal.controller';
import { TransactionService } from './services/transaction.service';

@Module({
  controllers: [PayPalController],
  providers: [PayPalService, TransactionService],
})
export class PayPalModule {}
 */

================
File: src/management/suscription/paypal/services/paypal.service.ts
================
import { Injectable } from '@nestjs/common';
import * as paypal from '@paypal/checkout-server-sdk';

@Injectable()
export class PayPalService {
  private environment:
    | paypal.core.SandboxEnvironment
    | paypal.core.LiveEnvironment;
  private client: paypal.core.PayPalHttpClient;

  constructor() {
    const clientId = process.env.PAYPAL_CLIENT_ID;
    const clientSecret = process.env.PAYPAL_CLIENT_SECRET;

    // Configura el entorno (Sandbox o Live)
    this.environment = new paypal.core.SandboxEnvironment(
      clientId,
      clientSecret,
    );
    this.client = new paypal.core.PayPalHttpClient(this.environment);
  }

  async createOrder(total: string, currency: string) {
    const request = new paypal.orders.OrdersCreateRequest();
    request.requestBody({
      intent: 'CAPTURE',
      purchase_units: [
        {
          amount: {
            currency_code: currency,
            value: total,
          },
        },
      ],
    });

    try {
      const response = await this.client.execute(request);
      return response.result;
    } catch (error) {
      throw new Error(`PayPal Order Creation Error: ${error.message}`);
    }
  }

  async captureOrder(orderId: string) {
    const request = new paypal.orders.OrdersCaptureRequest(orderId);
    request.requestBody({});

    try {
      const response = await this.client.execute(request);
      return response.result;
    } catch (error) {
      throw new Error(`PayPal Order Capture Error: ${error.message}`);
    }
  }
}

================
File: src/management/suscription/paypal/services/transaction.service.ts
================
/* import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';

@Injectable()
export class TransactionService {
  constructor(private readonly prisma: PrismaService) {}

  async createTransaction(data: {
    orderId: string;
    status: string;
    amount: number;
    currency: string;
    userId: string;
    tenant_id: string;
  }) {
    return this.prisma.transaction.create({ data });
  }

  async getTransactionsByUser(userId: string) {
    return this.prisma.transaction.findMany({
      where: { userId },
    });
  }
}
 */

================
File: src/management/user/dto/create-user.dto.ts
================
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsStrongPassword,
  IsUrl,
  Length,
} from 'class-validator';
import { role_type } from '@prisma/client';

export class BaseUserDto {
  @IsString({ message: 'El nombre debe ser un texto válido.' })
  @Length(2, 50, { message: 'El nombre debe tener entre 2 y 50 caracteres.' })
  @IsNotEmpty({ message: 'El nombre es obligatorio.' })
  name: string;

  @IsString({ message: 'El apellido debe ser un texto válido.' })
  @Length(3, 50, { message: 'El apellido debe tener entre 3 y 50 caracteres.' })
  last_name: string;

  @IsEmail({}, { message: 'El correo electrónico no tiene un formato válido.' })
  @IsNotEmpty({ message: 'El correo electrónico es obligatorio.' })
  email: string;

  @IsString({ message: 'El DNI debe ser un texto válido.' })
  @Length(7, 9, { message: 'El DNI debe tener entre 7 y 9 caracteres.' })
  @IsOptional()
  dni?: string;

  @IsOptional()
  birth_date?: Date;

  @IsString({ message: 'La nacionalidad debe ser un texto válido.' })
  @Length(3, 50, {
    message: 'La nacionalidad debe tener entre 3 y 50 caracteres.',
  })
  @IsOptional()
  nationality: string;

  @IsString({ message: 'El género debe ser un texto válido.' })
  @Length(1, 14, { message: 'El género debe tener entre 1 y 14 caracteres.' })
  @IsOptional()
  gender: string;

  @IsString({ message: 'El prefijo del teléfono debe ser un texto válido.' })
  @Length(1, 4, {
    message: 'El prefijo del teléfono debe tener entre 1 y 4 caracteres.',
  })
  @IsOptional()
  phone_prefix?: string;

  @IsString({ message: 'El número de teléfono debe ser un texto válido.' })
  @Length(4, 20, {
    message: 'El número de teléfono debe tener entre 4 y 20 caracteres.',
  })
  @IsOptional()
  phone?: string;

  @IsUrl({}, { message: 'La URL de la imagen no tiene un formato válido.' })
  @IsOptional()
  image: string;

  @IsString({ message: 'El rol debe ser un texto válido.' })
  @IsOptional()
  role: role_type;

  @IsOptional()
  tenant_id: string;
}

export class CreateUserDto extends BaseUserDto {
  @IsNotEmpty({ message: 'La contraseña es obligatoria.' })
  @IsStrongPassword(
    {
      minLength: 8,
      minNumbers: 1,
      minLowercase: 1,
      minUppercase: 1,
      minSymbols: 1,
    },
    {
      message:
        'La contraseña debe tener al menos 8 caracteres, incluyendo 1 número, 1 letra minúscula, 1 letra mayúscula y 1 símbolo.',
    },
  )
  password?: string;
}

export class GoogleUserDto {
  @IsOptional()
  name: string;

  @IsEmail({}, { message: 'El correo electrónico no tiene un formato válido.' })
  @IsNotEmpty({ message: 'El correo electrónico es obligatorio.' })
  email: string;

  @IsOptional()
  image: string;
}

================
File: src/management/user/dto/onboarding-user.dto.ts
================
import { tenant_type } from '@prisma/client';
import {
  IsEnum,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsInt,
  Min,
  MaxLength,
} from 'class-validator';

export class OnboardingDto {
  @IsNotEmpty({ message: 'El id del usuario es obligatorio' })
  user_id: string;

  @IsString()
  @IsNotEmpty({ message: 'El nombre es obligatorio' })
  @MaxLength(50, { message: 'El nombre no puede tener más de 50 caracteres' })
  name: string;

  @IsEnum(tenant_type, {
    message: `El tipo debe ser uno de los siguientes: ${Object.values(tenant_type).join(', ')}`,
  })
  type: tenant_type;

  @IsOptional()
  @IsInt({ message: 'El número de empleados debe ser un número entero' })
  @Min(1, { message: 'Debe haber al menos 1 empleado' })
  number_of_employees?: number;

  @IsOptional()
  @IsInt({ message: 'El número de pacientes debe ser un número entero' })
  @Min(1, { message: 'Debe haber al menos 1 paciente' })
  number_of_patients?: number;

  @IsString()
  @IsNotEmpty({ message: 'El motivo de registro es obligatorio' })
  @MaxLength(50, {
    message: 'El motivo de registro no puede tener más de 50 caracteres',
  })
  reason_register: string;

  @IsNotEmpty({ message: 'La especialidad es obligatoria' })
  speciality?: number[];
}

================
File: src/management/user/dto/update-user.dto.ts
================
import { PartialType } from '@nestjs/mapped-types';
import { CreateUserDto } from './create-user.dto';

export class UpdateUserDto extends PartialType(CreateUserDto) {}

================
File: src/management/user/entities/user.interface.ts
================
import { role_type } from '@prisma/client';
/* import { Tenant } from 'src/tenant/entities/tenant.interface';
 */
export interface User {
  id?: string;
  name?: string;
  last_name?: string;
  email?: string;
  dni?: string;
  dniType?: string;
  birthdate?: Date;
  nationality?: string;
  gender?: string;
  phone_prefix?: string;
  phone?: string;
  password?: string;
  google_id?: string;
  image?: string;
  role?: role_type;
  /*   tenant?: Tenant; */
  tenant_id?: string;
  createdAt?: Date;
  updatedAt?: Date;
}

================
File: src/management/user/roles.enum.ts
================
export enum Rol {
  Patient = 'patient',
  Physician = 'physician',
  Organization_owner = 'organization_owner',
}

================
File: src/management/user/user.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { UserController } from './user.controller';
import { UserService } from './user.service';

describe('UserController', () => {
  let controller: UserController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UserController],
      providers: [UserService],
    }).compile();

    controller = module.get<UserController>(UserController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/management/user/user.controller.ts
================
import {
  Controller,
  Get,
  Body,
  Patch,
  Param,
  Delete,
  Post,
} from '@nestjs/common';
import { UserService } from './user.service';
import { UpdateUserDto } from './dto/update-user.dto';
import { ApiTags } from '@nestjs/swagger';
import { OnboardingDto } from './dto/onboarding-user.dto';

@ApiTags('User')
@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post('onboarding')
  onboarding(@Body() onboardingDto: OnboardingDto) {
    return this.userService.onboarding(onboardingDto);
  }

  @Get()
  findAll() {
    return this.userService.findAll();
  }

  @Get(':id')
  findOneById(@Param('id') id: string) {
    return this.userService.findOneById(id);
  }
  @Get('email/:email')
  findOneByEmail(@Param('email') email: string) {
    return this.userService.findOneByEmail(email);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.userService.update(+id, updateUserDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.userService.remove(+id);
  }
}

================
File: src/management/user/user.module.ts
================
import { Module } from '@nestjs/common';
import { UserService } from './user.service';
import { UserController } from './user.controller';
import { PrismaService } from 'src/prisma/prisma.service';

@Module({
  controllers: [UserController],
  providers: [UserService, PrismaService],
})
export class UserModule {}

================
File: src/management/user/user.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { UserService } from './user.service';

describe('UserService', () => {
  let service: UserService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UserService],
    }).compile();

    service = module.get<UserService>(UserService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/management/user/user.service.ts
================
import { BadRequestException, Injectable } from '@nestjs/common';
// import { Tenant } from 'src/tenant/entities/tenant.entity';
import { PrismaService } from 'src/prisma/prisma.service';
import { UpdateUserDto } from './dto/update-user.dto';
import { OnboardingDto } from './dto/onboarding-user.dto';

@Injectable()
export class UserService {
  constructor(private readonly prisma: PrismaService) {}

  async onboarding(onboardingDto: OnboardingDto): Promise<object> {
    try {
      const { speciality, user_id, ...rest } = onboardingDto;

      const user = await this.prisma.user.findUnique({
        where: { id: user_id },
      });

      if (!user) {
        throw new BadRequestException('El usuario no existe');
      }

      await this.prisma.$transaction(async (transaction) => {
        const newTenant = await transaction.tenant.create({
          data: {
            type: onboardingDto.type,
          },
        });

        const existingPhysician = await transaction.physician.findFirst({
          where: { user_id },
        });
        if (existingPhysician) {
          throw new BadRequestException('El usuario ya es un médico.');
        }

        const newPhysician = await transaction.physician.create({
          data: {
            user_id,
            tenant_id: newTenant.id,
          },
        });
        const newPhysicianSpeciality = speciality.map((speciality) => {
          return {
            physician_id: newPhysician.id,
            speciality_id: speciality,
          };
        });

        await transaction.physician_speciality.createMany({
          data: newPhysicianSpeciality,
          skipDuplicates: true,
        });

        await transaction.user.update({
          where: { id: user_id },
          data: {
            tenant_id: newTenant.id,
          },
        });

        const newOrganization = await transaction.organization.create({
          data: {
            tenant_id: newTenant.id,
            ...rest,
          },
        });

        await transaction.organization_physician.create({
          data: {
            physician_id: newPhysician.id,
            organization_id: newOrganization.id,
            tenant_id: newTenant.id,
          },
        });
      });

      return { message: 'Onboarding completo.' };
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      console.log(error);
      throw new BadRequestException('No se pudo guardar la información.');
    }
  }

  async findAll(): Promise<any[]> {
    const users = await this.prisma.user.findMany();
    return users;
  }

  async findOneById(id: string) {
    try {
      const user = await this.prisma.user.findUnique({
        where: { id: id },
      });
      if (user) {
        return { message: 'Success', user: user };
      } else {
        return { message: 'El usuario no existe' };
      }
    } catch (error) {
      return { message: 'Error en la consulta', Error: error };
    }
  }

  async findOneByEmail(email: string) {
    try {
      console.log(email);
      const user = await this.prisma.user.findUnique({
        where: { email: email },
      });
      if (user) {
        return { message: 'Success', user: user };
      } else {
        return { message: 'El usuario no existe' };
      }
    } catch (error) {
      return { message: 'Error en la consulta', Error: error };
    }
  }

  update(id: number, updateUserDto: UpdateUserDto) {
    console.log(updateUserDto);
    return `This action updates a #${id} user`;
  }

  remove(id: number) {
    return `This action removes a #${id} user`;
  }
}

================
File: src/medical-scheduling/appointments/appointments.controller.ts
================
import {
  Body,
  Controller,
  Get,
  Param,
  ParseUUIDPipe,
  Patch,
  Post,
  Query,
} from '@nestjs/common';
import { CreateAppointmentDto } from './dto/create-appointment.dto';
import { AppointmentsService } from './appointments.service';
import { status_type } from '@prisma/client';

@Controller('appointments')
export class AppointmentsController {
  constructor(private readonly appointmentsService: AppointmentsService) {}

  @Post()
  async createAppointment(@Body() createAppointmentDto: CreateAppointmentDto) {
    return this.appointmentsService.createAppointment(createAppointmentDto);
  }

  @Get(':userId')
  async getAppointmentsByUser(
    @Param('userId', new ParseUUIDPipe()) userId: string,
    @Query('status') status?: status_type,
    @Query('page') page?: number,
    @Query('pageSize') pageSize?: number,
    @Query('orderBy') orderBy?: string,
    @Query('orderDirection') orderDirection?: 'asc' | 'desc',
  ) {
    return this.appointmentsService.getAppointmentsByUser(userId, {
      status,
      page,
      pageSize,
      orderBy,
      orderDirection,
    });
  }

  @Patch(':id/status')
  async updateAppointmentStatus(
    @Param('id', new ParseUUIDPipe()) id: string,
    @Body('status') status: status_type,
    @Body('reason') reason?: string,
  ) {
    return this.appointmentsService.updateAppointmentStatus(id, status, reason);
  }
}

================
File: src/medical-scheduling/appointments/appointments.module.ts
================
import { Module } from '@nestjs/common';
import { AppointmentsController } from './appointments.controller';
import { AppointmentsService } from './appointments.service';
import { PrismaService } from 'src/prisma/prisma.service';

@Module({
  imports: [],
  controllers: [AppointmentsController],
  providers: [AppointmentsService, PrismaService],
})
export class AppointmentsModule {}

================
File: src/medical-scheduling/appointments/appointments.service.ts
================
import {
  Injectable,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { CreateAppointmentDto } from './dto/create-appointment.dto';
import {
  PaginationParams,
  parsePaginationAndSorting,
} from 'src/utils/pagination.helper';
import { PrismaService } from 'src/prisma/prisma.service';
import { appointment, status_type } from '@prisma/client';

@Injectable()
export class AppointmentsService {
  constructor(private prisma: PrismaService) {}

  async createAppointment(
    data: CreateAppointmentDto,
  ): Promise<{ message: string }> {
    // Verificar que las fechas de inicio y fin sean válidas
    if (!data.start || !data.end || data.start >= data.end) {
      throw new BadRequestException(
        'La fecha de inicio debe ser anterior a la fecha de fin',
      );
    }

    try {
      const patientExists = await this.prisma.patient.findUnique({
        where: { id: data.patient_id },
      });
      if (!patientExists) {
        throw new BadRequestException('El paciente no existe');
      }

      const physicianExists = await this.prisma.physician.findUnique({
        where: { id: data.physician_id },
      });
      if (!physicianExists) {
        throw new BadRequestException('El médico no existe');
      }

      // Verificar si hay conflicto de citas
      const conflict = await this.prisma.appointment.findFirst({
        where: {
          physician_id: data.physician_id,
          AND: [
            { start: { lte: data.end } },
            { end: { gte: data.start } },
            { status: { not: 'cancelada' } },
          ],
        },
      });

      if (conflict) {
        throw new BadRequestException(
          'El médico ya tiene una cita en ese horario',
        );
      }

      // Iniciar una transacción para asegurar la consistencia de los datos
      await this.prisma.$transaction(async (prisma) => {
        // Crear la cita
        const appointment = await prisma.appointment.create({ data });

        if (!appointment) {
          throw new InternalServerErrorException('Error al crear la cita');
        }

        // Crear el evento médico asociado directamente con Prisma
        await prisma.medical_event.create({
          data: {
            appointment_id: appointment.id,
            patient_id: data.patient_id,
            physician_id: data.physician_id,
            tenant_id: data.tenant_id,
          },
        });
      });

      return { message: 'Cita creada exitosamente' };
    } catch (error) {
      if (error instanceof PrismaClientKnownRequestError) {
        throw new InternalServerErrorException('Error al crear la cita');
      }
      throw error;
    }
  }

  async getAppointmentsByUser(
    userId: string,
    params: { status?: status_type } & PaginationParams,
  ): Promise<appointment[]> {
    // Desestructurar los parámetros de paginación y ordenación
    const { skip, take, orderBy, orderDirection } =
      parsePaginationAndSorting(params);

    try {
      const appointments = await this.prisma.appointment.findMany({
        where: {
          OR: [{ patient_id: userId }, { physician_id: userId }],
          ...(params.status && { status: params.status }),
        },
        skip,
        take,
        orderBy: { [orderBy]: orderDirection },
      });

      return appointments;
    } catch (error) {
      throw new InternalServerErrorException(
        `Error al obtener las citas: ${error.message}`,
      );
    }
  }

  async updateAppointmentStatus(
    id: string,
    status: status_type,
    reason?: string,
  ): Promise<{ message: string }> {
    const appointment = await this.prisma.appointment.findUnique({
      where: { id },
    });

    if (!appointment) {
      throw new Error('Cita no encontrada');
    }
    if (status === 'cancelada' && !reason) {
      throw new Error('Se requiere una razón para cancelar la cita');
    }
    if (
      (appointment.status === 'pendiente' &&
        !['atendida', 'cancelada'].includes(status)) ||
      (appointment.status === 'atendida' && status !== 'cancelada') ||
      appointment.status === 'cancelada'
    ) {
      throw new Error(
        `Transición no permitida desde el estado ${appointment.status} a ${status}`,
      );
    }

    try {
      await this.prisma.appointment.update({
        where: { id },
        data: { status, cancelation_reason: reason || null },
      });

      return { message: `Estado de la cita actualizado a "${status}"` };
    } catch (error) {
      if (
        error instanceof PrismaClientKnownRequestError &&
        error.code === 'P2025'
      ) {
        throw new Error('Cita no encontrada');
      }
      throw new Error(`Error al actualizar la cita: ${error.message}`);
    }
  }
}

================
File: src/medical-scheduling/appointments/dto/create-appointment.dto.ts
================
import {
  IsUUID,
  IsString,
  IsDate,
  IsEnum,
  IsOptional,
  IsNotEmpty,
} from 'class-validator';
import { Transform } from 'class-transformer';
import { status_type } from '@prisma/client';

export class CreateAppointmentDto {
  @IsString()
  @IsNotEmpty()
  consultation_reason: string;

  @IsDate()
  @IsNotEmpty()
  @Transform(({ value }) => new Date(value))
  start: Date;

  @IsDate()
  @IsNotEmpty()
  @Transform(({ value }) => new Date(value))
  end: Date;

  @IsUUID()
  @IsNotEmpty()
  patient_id: string;

  @IsUUID()
  @IsNotEmpty()
  physician_id: string;

  @IsEnum(['atendida', 'cancelada', 'pendiente'])
  @IsOptional()
  status?: status_type;

  @IsString()
  @IsOptional()
  comments?: string;

  @IsUUID()
  @IsNotEmpty()
  tenant_id: string;
}

================
File: src/medical-scheduling/medical-events/dto/create-medical-event.dto.ts
================
import { IsUUID, IsString, IsNotEmpty, IsOptional } from 'class-validator';

export class CreateMedicalEventDto {
  @IsUUID()
  @IsNotEmpty()
  appointment_id: string;

  @IsUUID()
  @IsNotEmpty()
  patient_id: string;

  @IsUUID()
  @IsNotEmpty()
  physician_id: string;

  @IsString()
  @IsOptional()
  physician_comments?: string;

  @IsString()
  @IsOptional()
  main_diagnostic_cie?: string;

  @IsString()
  @IsOptional()
  evolution?: string;

  @IsString()
  @IsOptional()
  procedure?: string;

  @IsString()
  @IsOptional()
  treatment?: string;

  @IsUUID()
  @IsNotEmpty()
  tenant_id: string;
}

================
File: src/medical-scheduling/medical-events/medical-events.controller.ts
================
import { Body, Controller, Get, Post, Query } from '@nestjs/common';
import { CreateMedicalEventDto } from './dto/create-medical-event.dto';
import { MedicalEventsService } from './medical-events.service';

@Controller('medical-events')
export class MedicalEventsController {
  constructor(private readonly medicalEventsService: MedicalEventsService) {}

  @Post()
  async createMedicalEvent(
    @Body() createMedicalEventDto: CreateMedicalEventDto,
  ) {
    return this.medicalEventsService.createMedicalEvent(createMedicalEventDto);
  }

  @Get()
  async getMedicalEvents(
    @Query('patient_id') patient_id?: string,
    @Query('physician_id') physician_id?: string,
    @Query('page') page?: number,
    @Query('pageSize') pageSize?: number,
    @Query('orderBy') orderBy?: string,
    @Query('orderDirection') orderDirection?: 'asc' | 'desc',
  ) {
    const filters = {
      patient_id,
      physician_id,
      page,
      pageSize,
      orderBy,
      orderDirection,
    };
    return this.medicalEventsService.getMedicalEvents(filters);
  }
}

================
File: src/medical-scheduling/medical-events/medical-events.module.ts
================
import { Module } from '@nestjs/common';
import { MedicalEventsController } from './medical-events.controller';
import { MedicalEventsService } from './medical-events.service';
import { PrismaService } from 'src/prisma/prisma.service';

@Module({
  controllers: [MedicalEventsController],
  providers: [MedicalEventsService, PrismaService],
  exports: [],
})
export class MedicalEventsModule {}

================
File: src/medical-scheduling/medical-events/medical-events.service.ts
================
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { parsePaginationAndSorting } from 'src/utils/pagination.helper';
import { CreateMedicalEventDto } from './dto/create-medical-event.dto';
import { medical_event } from '@prisma/client';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class MedicalEventsService {
  constructor(private prisma: PrismaService) {}

  async createMedicalEvent(
    data: CreateMedicalEventDto,
  ): Promise<{ message: string }> {
    try {
      await this.prisma.medical_event.create({
        data: {
          appointment_id: data.appointment_id,
          patient_id: data.patient_id,
          physician_id: data.physician_id,
          physician_comments: data.physician_comments ?? '',
          main_diagnostic_cie: data.main_diagnostic_cie ?? '',
          evolution: data.evolution ?? '',
          procedure: data.procedure ?? '',
          treatment: data.treatment ?? '',
          tenant_id: data.tenant_id,
        },
      });

      return { message: `Evento médico creado exitosamente` };
    } catch (error) {
      throw new InternalServerErrorException(
        `Error al crear el evento médico: ${error.message}`,
      );
    }
  }

  async getMedicalEvents(filters?: {
    patient_id?: string;
    physician_id?: string;
    page?: number;
    pageSize?: number;
    orderBy?: string;
    orderDirection?: 'asc' | 'desc';
  }): Promise<medical_event[]> {
    const { skip, take, orderBy, orderDirection } =
      parsePaginationAndSorting(filters);

    try {
      const medicalEvents = await this.prisma.medical_event.findMany({
        where: {
          ...(filters?.patient_id && { patient_id: filters.patient_id }),
          ...(filters?.physician_id && { physician_id: filters.physician_id }),
        },
        skip,
        take,
        orderBy: { [orderBy]: orderDirection },
      });

      return medicalEvents;
    } catch (error) {
      throw new InternalServerErrorException(
        'Error al obtener los eventos médicos',
        error.message,
      );
    }
  }
}

================
File: src/medical-scheduling/modules/background/background.controller.ts
================
import {
  Controller,
  Post,
  Body,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { BackgroundService } from './background.service';
import { CreateBackgroundDto } from './dto/create-background.dto';

@Controller('background')
export class BackgroundController {
  constructor(private readonly backgroundService: BackgroundService) {}

  @Post()
  async createBackground(@Body() data: CreateBackgroundDto) {
    try {
      return await this.backgroundService.createBackground(data);
    } catch (error) {
      throw new HttpException(
        {
          message: 'Error creating background',
          error: error.message,
        },
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}

================
File: src/medical-scheduling/modules/background/background.module.ts
================
import { Module } from '@nestjs/common';
import { BackgroundController } from './background.controller';
import { BackgroundService } from './background.service';
import { PrismaService } from 'src/prisma/prisma.service';

@Module({
  controllers: [BackgroundController],
  providers: [BackgroundService, PrismaService],
})
export class BackgroundModule {}

================
File: src/medical-scheduling/modules/background/background.service.ts
================
import {
  Injectable,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { CreateBackgroundDto } from './dto/create-background.dto';
import { Prisma } from '@prisma/client';

@Injectable()
export class BackgroundService {
  constructor(private prisma: PrismaService) {}

  async createBackground(data: CreateBackgroundDto) {
    try {
      const backgroundCount = await this.prisma.background.count({
        where: {
          patient_id: data.patient_id,
        },
      });

      if (backgroundCount > 0) {
        throw new BadRequestException(
          'Background already exists for this patient',
        );
      }

      await this.prisma.background.create({
        data: {
          ...data,
        },
      });

      return { message: 'Background created successfully' };
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        throw new InternalServerErrorException(
          `Database error: ${error.message}`,
        );
      }
      throw new InternalServerErrorException(
        error.message || 'Error creating background',
      );
    }
  }
}

================
File: src/medical-scheduling/modules/background/dto/create-background.dto.ts
================
import { IsNotEmpty, IsString, MaxLength } from 'class-validator';

export class CreateBackgroundDto {
  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  patient_id: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  vaccinations: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  allergies: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  pathological_history: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  family_medical_history: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  non_pathological_history: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  surgical_history: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  childhood_medical_history: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  current_medication: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(255)
  tenant_id: string;
}

================
File: src/medical-scheduling/modules/medicine/medicine.controller.ts
================
import { Controller, Post, Query } from '@nestjs/common';
import { MedicineService } from './medicine.service';

@Controller('medicine')
export class MedicineController {
  constructor(private readonly medicineService: MedicineService) {}

  @Post('searchMedicine')
  searchMedicine(
    @Query('drug') principioActivo: string,
    @Query('product') product: string,
  ) {
    return this.medicineService.searchMedicine(principioActivo, product);
  }
}

================
File: src/medical-scheduling/modules/medicine/medicine.module.ts
================
import { Module } from '@nestjs/common';
import { MedicineService } from './medicine.service';
import { MedicineController } from './medicine.controller';
import { HttpModule } from '@nestjs/axios';

@Module({
  imports: [HttpModule],
  controllers: [MedicineController],
  providers: [MedicineService],
})
export class MedicineModule {}

================
File: src/medical-scheduling/modules/medicine/medicine.service.ts
================
import { HttpException, Injectable } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';

@Injectable()
export class MedicineService {
  private readonly apiUrl = 'https://www.datos.gov.co/resource/i7cb-raxc.json';

  constructor(private readonly httpService: HttpService) {}

  async searchMedicine(principioActivo: string, producto: string) {
    const prActivo = principioActivo
      ? `principioactivo%20like%20%27%25${principioActivo.toUpperCase()}%25%27`
      : undefined;
    const pr = producto
      ? `producto%20like%20%27%25${producto.toUpperCase()}%25%27`
      : undefined;
    let query = '';
    if (pr && prActivo) {
      query = `${this.apiUrl}?$where=${pr}OR%20${prActivo}`;
    } else if (pr) {
      query = `${this.apiUrl}?$where=${pr}`;
    } else if (prActivo) {
      query = `${this.apiUrl}?$where=${prActivo}`;
    } else {
      query = this.apiUrl;
    }

    try {
      const medicines = await firstValueFrom(this.httpService.get(query));
      return medicines.data;
    } catch (error) {
      console.log(error);
      throw new HttpException('La medicina no ha podido ser consultada', 500);
    }
  }
}

================
File: src/medical-scheduling/modules/patient-studies/dto/create-patient-study.dto.ts
================
import {
  IsString,
  IsOptional,
  Length,
  IsBoolean,
  IsUUID,
  IsNotEmpty,
} from 'class-validator';

export class CreatePatientStudyDto {
  @IsUUID('4', { message: 'El ID del paciente debe ser un UUID válido' })
  patient_id: string;

  @IsUUID('4', { message: 'El ID del médico debe ser un UUID válido' })
  physician_id: string;

  @IsOptional()
  @IsString({ message: 'La URL debe ser una cadena de texto válida' })
  url?: string;

  @IsString({ message: 'El título debe ser una cadena de texto' })
  @Length(3, 100, { message: 'El título debe tener entre 3 y 100 caracteres' })
  title: string;

  @IsString({ message: 'La descripción debe ser una cadena de texto' })
  @Length(3, 500, {
    message: 'La descripción debe tener entre 3 y 500 caracteres',
  })
  description: string;
  /* 
  @IsInt({ message: 'El ID del tipo de estudio debe ser un número entero' }) */
  @IsNotEmpty()
  cat_study_type_id: number;

  @IsUUID('4', { message: 'El ID del inquilino debe ser un UUID válido' })
  tenant_id: string;

  @IsBoolean({ message: 'El campo is_deleted debe ser un valor booleano' })
  is_deleted: boolean = false;
}

================
File: src/medical-scheduling/modules/patient-studies/dto/update-patient-study.dto.ts
================
import { PartialType } from '@nestjs/mapped-types';
import { CreatePatientStudyDto } from './create-patient-study.dto';

export class UpdatePatientStudyDto extends PartialType(CreatePatientStudyDto) {}

================
File: src/medical-scheduling/modules/patient-studies/entities/patient-study.interface.ts
================
export interface PatientStudy {
  id?: string;
  patient_id: string;
  physician_id: string;
  url?: string;
  title: string;
  description: string;
  cat_study_type_id: number;
  cat_study_type?: {
    id: number;
    name: string;
  };
  tenant_id: string;
  is_deleted: boolean;
  createdAt?: Date;
  updatedAt?: Date;
}

================
File: src/medical-scheduling/modules/patient-studies/patient-studies.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UploadedFile,
  UseInterceptors,
  ParseFilePipe,
  MaxFileSizeValidator,
  FileTypeValidator,
  BadRequestException,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { PatientStudiesService } from './patient-studies.service';
import { CreatePatientStudyDto } from './dto/create-patient-study.dto';
import { UpdatePatientStudyDto } from './dto/update-patient-study.dto';
import { FileUploadService } from '../../../utils/file_upload/file_upload.service';
import { Multer } from 'multer';
import { CatStudyTypeService } from '../../../catalogs/cat-study-type/cat-study-type.service';

@Controller('patient-studies')
export class PatientStudiesController {
  constructor(
    private readonly patientStudiesService: PatientStudiesService,
    private readonly fileUploadService: FileUploadService,
    private readonly catStudyTypeService: CatStudyTypeService,
  ) {}

  @Post()
  @UseInterceptors(FileInterceptor('file'))
  async create(
    @UploadedFile(
      new ParseFilePipe({
        validators: [
          new MaxFileSizeValidator({
            maxSize: 10 * 1024 * 1024, // 10MB para PDF, 5MB para imágenes
            message:
              'File exceeds the maximum size of 10MB for PDFs or 5MB for images',
          }),
          new FileTypeValidator({
            fileType: /^(image\/(jpg|jpeg|png|webp|svg)|application\/pdf)$/i,
          }),
        ],
      }),
    )
    file: Multer.File,
    @Body() createPatientStudyDto: CreatePatientStudyDto,
  ) {
    const catStudyType = await this.catStudyTypeService.findOne(
      createPatientStudyDto.cat_study_type_id,
    );
    if (!catStudyType) {
      throw new BadRequestException('Invalid cat_study_type_id');
    }
    if (file) {
      const uploadResult = await this.fileUploadService.uploadFile(file);
      createPatientStudyDto.url = uploadResult.url;
    }
    return this.patientStudiesService.create(createPatientStudyDto);
  }

  @Get()
  findAll() {
    return this.patientStudiesService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.patientStudiesService.findOne(id);
  }

  @Patch(':id')
  async update(
    @Param('id') id: string,
    @Body() updatePatientStudyDto: UpdatePatientStudyDto,
  ) {
    const catStudyType = await this.catStudyTypeService.findOne(
      updatePatientStudyDto.cat_study_type_id,
    );
    if (!catStudyType) {
      throw new BadRequestException('Invalid cat_study_type_id');
    }
    return this.patientStudiesService.update(id, updatePatientStudyDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.patientStudiesService.remove(id);
  }
}

================
File: src/medical-scheduling/modules/patient-studies/patient-studies.module.ts
================
import { Module } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { PatientStudiesService } from './patient-studies.service';
import { PatientStudiesController } from './patient-studies.controller';
import { FileUploadService } from '../../../utils/file_upload/file_upload.service';
import { FileUploadRepository } from 'src/utils/file_upload/file_upload.repository';
import { CatStudyTypeService } from '../../../catalogs/cat-study-type/cat-study-type.service';

@Module({
  controllers: [PatientStudiesController],
  providers: [
    PatientStudiesService,
    CatStudyTypeService,
    PrismaService,
    FileUploadService,
    FileUploadRepository,
  ],
})
export class PatientStudiesModule {}

================
File: src/medical-scheduling/modules/patient-studies/patient-studies.service.ts
================
import { BadRequestException, Injectable } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { CreatePatientStudyDto } from './dto/create-patient-study.dto';
import { UpdatePatientStudyDto } from './dto/update-patient-study.dto';
import { PatientStudy } from './entities/patient-study.interface';

@Injectable()
export class PatientStudiesService {
  constructor(private prisma: PrismaService) {}

  async create(
    createPatientStudyDto: CreatePatientStudyDto,
  ): Promise<PatientStudy> {
    createPatientStudyDto.cat_study_type_id = Number(
      createPatientStudyDto.cat_study_type_id,
    );
    return await this.prisma.patient_study.create({
      data: {
        ...createPatientStudyDto,
        is_deleted: false,
      },
    });
  }

  async findAll(): Promise<PatientStudy[]> {
    return this.prisma.patient_study.findMany({
      where: { is_deleted: false },
    });
  }

  async findOne(id: string): Promise<PatientStudy> {
    return this.prisma.patient_study.findFirst({
      where: { id, is_deleted: false },
    });
  }

  async findByPatientId(patientId: string): Promise<PatientStudy[]> {
    try {
      return this.prisma.patient_study.findMany({
        where: { patient_id: patientId, is_deleted: false },
      });
    } catch (error) {
      throw new BadRequestException('Ocurrio un error: ' + error.message);
    }
  }

  async update(
    id: string,
    updatePatientStudyDto: UpdatePatientStudyDto,
  ): Promise<PatientStudy> {
    return this.prisma.patient_study.update({
      where: { id },
      data: updatePatientStudyDto,
    });
  }

  async remove(id: string): Promise<PatientStudy> {
    return this.prisma.patient_study.update({
      where: { id },
      data: { is_deleted: true },
    });
  }
}

================
File: src/medical-scheduling/modules/physical-examination-data/physical_subsystem/physical_subsystem.interface.ts
================
export interface physicalSubsystem {
  id?: number;
  name: string;
}

================
File: src/medical-scheduling/modules/physical-examination-data/physical_subsystem/physical_subsystem.service.ts
================
import { Injectable } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { physicalSubsystem } from './physical_subsystem.interface';
import {
  PaginationParams,
  parsePaginationAndSorting,
} from 'src/utils/pagination.helper';

@Injectable()
export class PhysicalSubsystemService {
  constructor(private readonly prisma: PrismaService) {}

  async create(physicalSubsystem: physicalSubsystem) {
    try {
      await this.prisma.cat_physical_subsystem.create({
        data: physicalSubsystem,
      });
      return { message: 'El subsistema físico ha sido creado' };
    } catch (error) {
      return { message: 'Error al crear el subsistema', Error: error };
    }
  }

  async findOneById(id: string) {
    try {
      const phy_sub = await this.prisma.cat_physical_subsystem.findUnique({
        where: { id: parseInt(id) },
      });
      if (phy_sub) {
        return phy_sub;
      } else {
        return { message: 'El valor solicitado no existe' };
      }
    } catch (error) {
      return { message: 'Error al buscar el subsistema', Error: error };
    }
  }

  async findAll(pagination: PaginationParams) {
    const { skip, take, orderBy, orderDirection } =
      parsePaginationAndSorting(pagination);
    try {
      const phy_subs = await this.prisma.cat_physical_subsystem.findMany({
        take,
        skip,
        orderBy: { [orderBy]: orderDirection },
      });
      if (phy_subs.length > 0) {
        return phy_subs;
      } else {
        return { message: 'No existen datos' };
      }
    } catch (error) {
      return { message: 'Error al buscar los subsistemas', Error: error };
    }
  }
}

================
File: src/medical-scheduling/modules/physical-examination-data/physical-examination/physical_examination.interface.ts
================
import {
  IsUUID,
  IsString,
  IsNotEmpty,
  IsOptional,
  IsDate,
} from 'class-validator';

export class physicalExaminationDto {
  @IsUUID(undefined, { message: 'ID debe ser un UUID válido' })
  @IsOptional()
  id?: string;

  @IsOptional()
  physical_subsystem_id?: number;

  @IsUUID(undefined, { message: 'El ID del paciente debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del paciente no puede estar vacío' })
  patient_id: string;

  @IsString({ message: 'La descripción debe ser una cadena de texto' })
  @IsNotEmpty({ message: 'La descripción no puede estar vacía' })
  description: string;

  @IsUUID(undefined, {
    message: 'El ID del evento médico debe ser un UUID válido',
  })
  @IsNotEmpty({ message: 'El ID del evento médico no puede estar vacío' })
  medical_event_id: string;

  @IsUUID(undefined, { message: 'El ID del inquilino debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del inquilino no puede estar vacío' })
  tenant_id: string;

  @IsDate({ message: 'La fecha de creación debe ser una fecha válida' })
  @IsNotEmpty({ message: 'La fecha de creación no puede estar vacía' })
  createdAt: Date;

  @IsDate({ message: 'La fecha de actualización debe ser una fecha válida' })
  @IsNotEmpty({ message: 'La fecha de actualización no puede estar vacía' })
  updatedAt: Date;
}

================
File: src/medical-scheduling/modules/physical-examination-data/physical-examination/physical-examination.service.ts
================
import { Injectable } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import {
  PaginationParams,
  parsePaginationAndSorting,
} from 'src/utils/pagination.helper';
import { physicalExaminationDto } from './physical_examination.interface';

@Injectable()
export class PhysicalExaminationService {
  constructor(private readonly prisma: PrismaService) {}

  async create(
    physical_examinations: physicalExaminationDto[],
  ): Promise<object> {
    try {
      const result = [];
      for (const physical_examination of physical_examinations) {
        const { physical_subsystem_id, medical_event_id, patient_id, ...rest } =
          physical_examination;

        const patient = await this.prisma.patient.findUnique({
          where: { id: patient_id },
        });
        if (!patient) {
          result.push({
            patient_id,
            message: 'El paciente no existe',
          });
          continue;
        }

        if (physical_subsystem_id) {
          const existingRelation =
            await this.prisma.physical_examination.findFirst({
              where: {
                medical_event_id,
                physical_subsystem_id,
              },
            });

          if (existingRelation) {
            result.push({
              patient_id,
              message:
                'Ya existe un examen físico con el mismo subsistema y evento médico',
            });
            continue;
          }
        }

        const phy_exa = await this.prisma.physical_examination.create({
          data: {
            ...rest,
            medical_event: { connect: { id: medical_event_id } },
            user: { connect: { id: patient_id } },
            ...(physical_subsystem_id && {
              physical_subsystem: { connect: { id: physical_subsystem_id } },
            }),
          },
        });

        if (phy_exa.id) {
          result.push({
            patient_id,
            message: 'El examen físico ha sido correctamente generado',
          });
        } else {
          result.push({
            patient_id,
            message: 'Error al crear el Examen Físico',
          });
        }
      }
      return result;
    } catch (error) {
      return {
        message: 'Error al crear los Exámenes Físicos',
        error: error.message || error,
      };
    }
  }

  async findOneById(id: string) {
    try {
      const phy_exa = await this.prisma.physical_examination.findUnique({
        where: { id: id },
      });

      if (!phy_exa) throw new Error('El examen físico no existe');

      return phy_exa;
    } catch (error) {
      return { message: 'Error al buscar el exámen', Error: error };
    }
  }

  async findAll(pagination: PaginationParams, patient_id: string) {
    const { skip, take, orderBy, orderDirection } =
      parsePaginationAndSorting(pagination);
    try {
      const phy_exas = await this.prisma.physical_examination.findMany({
        where: { patient_id: patient_id },
        take,
        skip,
        orderBy: { [orderBy]: orderDirection },
      });
      if (phy_exas.length > 0) {
        return phy_exas;
      } else {
        return { message: 'No existen datos' };
      }
    } catch (error) {
      return { message: 'Error al buscar los exámenes', Error: error };
    }
  }

  async update(physicalExaminations: physicalExaminationDto[]) {
    const failedExams = [];

    try {
      await this.prisma.$transaction(async (prisma) => {
        for (const exam of physicalExaminations) {
          const phy_exa = await prisma.physical_examination.findUnique({
            where: { id: exam.id },
          });

          if (!phy_exa) {
            failedExams.push({
              id: exam.id,
              message: 'El examen físico no existe',
            });
            continue;
          }

          await prisma.physical_examination.update({
            where: { id: exam.id },
            data: exam,
          });
        }
      });

      if (failedExams.length === 0) {
        return {
          message: 'Todos los exámenes fueron actualizados correctamente',
        };
      } else {
        return {
          message:
            'Algunos exámenes no pudieron ser actualizados. Vuelva a intentarlo',
          failedExams,
        };
      }
    } catch (error) {
      return { message: 'Error al actualizar los exámenes', Error: error };
    }
  }

  async delete(id: string) {
    try {
      const phy_exa = await this.prisma.physical_examination.findUnique({
        where: { id },
      });

      if (!phy_exa) {
        return { message: 'El examen físico no existe' };
      }

      await this.prisma.physical_examination.delete({
        where: { id },
      });

      return { message: 'El examen físico ha sido eliminado' };
    } catch (error) {
      return { message: 'Error al eliminar el examen', error };
    }
  }
}

================
File: src/medical-scheduling/modules/physical-exploration-data/physical-exploration-area/dto/create-physical-exploration-area.dto.ts
================
import { IsNotEmpty, IsString, Length } from 'class-validator';

export class CreatePhysicalExplorationAreaDto {
  @IsString()
  @IsNotEmpty()
  @Length(1, 100)
  name_on_library: string;

  @IsString()
  @IsNotEmpty()
  @Length(1, 100)
  name: string;
}

================
File: src/medical-scheduling/modules/physical-exploration-data/physical-exploration-area/physical-exploration-area.controller.ts
================
import {
  Body,
  Controller,
  HttpException,
  HttpStatus,
  Post,
} from '@nestjs/common';
import { PhysicalExplorationAreaService } from './physical-exploration-area.service';
import { CreatePhysicalExplorationAreaDto } from './dto/create-physical-exploration-area.dto';

@Controller('physical-exploration-areas')
export class PhysicalExplorationAreaController {
  constructor(
    private readonly physicalExplorationAreaService: PhysicalExplorationAreaService,
  ) {}

  @Post()
  async createPhysicalExplorationArea(
    @Body() data: CreatePhysicalExplorationAreaDto,
  ) {
    try {
      return await this.physicalExplorationAreaService.createPhysicalExplorationArea(
        data,
      );
    } catch (error) {
      throw new HttpException(
        {
          message: 'Error creating physical exploration area',
          error: error.message,
        },
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}

================
File: src/medical-scheduling/modules/physical-exploration-data/physical-exploration-area/physical-exploration-area.module.ts
================
import { Module } from '@nestjs/common';
import { PhysicalExplorationAreaController } from './physical-exploration-area.controller';
import { PrismaService } from 'src/prisma/prisma.service';
import { PhysicalExplorationAreaService } from './physical-exploration-area.service';

@Module({
  controllers: [PhysicalExplorationAreaController],
  providers: [PrismaService, PhysicalExplorationAreaService],
})
export class PhysicalExplorationAreaModule {}

================
File: src/medical-scheduling/modules/physical-exploration-data/physical-exploration-area/physical-exploration-area.service.ts
================
import {
  Injectable,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { CreatePhysicalExplorationAreaDto } from './dto/create-physical-exploration-area.dto';
import { Prisma } from '@prisma/client';

@Injectable()
export class PhysicalExplorationAreaService {
  constructor(private prisma: PrismaService) {}

  async createPhysicalExplorationArea(
    data: CreatePhysicalExplorationAreaDto,
  ): Promise<{ message: string }> {
    try {
      const existingCount = await this.prisma.physical_exploration_area.count({
        where: {
          OR: [{ name_on_library: data.name_on_library }, { name: data.name }],
        },
      });

      if (existingCount > 0) {
        throw new BadRequestException(
          'A physical exploration area with the same name or name_on_library already exist',
        );
      }

      await this.prisma.physical_exploration_area.create({
        data,
      });

      return { message: 'Physical exploration area created successfully' };
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        throw new InternalServerErrorException(
          `Database error: ${error.message}`,
        );
      }

      throw new InternalServerErrorException(
        error.message || 'Error creating physical exploration area',
      );
    }
  }
}

================
File: src/medical-scheduling/modules/physical-exploration-data/physical-exploration/dto/create-physical-exploration.dto.ts
================
import {
  IsUUID,
  IsString,
  IsInt,
  Min,
  IsNotEmpty,
  Length,
} from 'class-validator';

export class CreatePhysicalExplorationDto {
  @IsUUID()
  @IsNotEmpty()
  patient_id: string;

  @IsUUID()
  @IsNotEmpty()
  physician_id: string;

  @IsUUID()
  @IsNotEmpty()
  medical_event_id: string;

  @IsString()
  @IsNotEmpty()
  @Length(1, 500)
  description: string;

  @IsInt()
  @IsNotEmpty()
  @Min(1)
  physical_exploration_area_id: number;

  @IsUUID()
  @IsNotEmpty()
  tenant_id: string;
}

================
File: src/medical-scheduling/modules/physical-exploration-data/physical-exploration/dto/update-physical-exploration.dto.ts
================
import { OmitType, PartialType } from '@nestjs/mapped-types';
import { CreatePhysicalExplorationDto } from './create-physical-exploration.dto';
import { IsUUID, IsNotEmpty } from 'class-validator';

export class UpdatePhysicalExplorationDto extends PartialType(
  OmitType(CreatePhysicalExplorationDto, ['medical_event_id'] as const),
) {
  @IsUUID()
  @IsNotEmpty()
  medical_event_id: string;
}

================
File: src/medical-scheduling/modules/physical-exploration-data/physical-exploration/physical-exploration.controller.ts
================
import { Body, Controller, HttpException, Post } from '@nestjs/common';
import { PhysicalExplorationService } from './physical-exploration.service';
import { CreatePhysicalExplorationDto } from './dto/create-physical-exploration.dto';
import { UpdatePhysicalExplorationDto } from './dto/update-physical-exploration.dto';

@Controller('physical-explorations')
export class PhysicalExplorationController {
  constructor(
    private readonly physicalExplorationService: PhysicalExplorationService,
  ) {}

  @Post()
  async createPhysicalExploration(
    @Body() data: CreatePhysicalExplorationDto | UpdatePhysicalExplorationDto,
  ) {
    try {
      return this.physicalExplorationService.createPhysicalExploration(data);
    } catch (error) {
      throw new HttpException(
        'Error creating physical exploration',
        error.message,
      );
    }
  }
}

================
File: src/medical-scheduling/modules/physical-exploration-data/physical-exploration/physical-exploration.module.ts
================
import { Module } from '@nestjs/common';
import { PhysicalExplorationController } from './physical-exploration.controller';
import { PrismaService } from 'src/prisma/prisma.service';
import { PhysicalExplorationService } from './physical-exploration.service';

@Module({
  controllers: [PhysicalExplorationController],
  providers: [PrismaService, PhysicalExplorationService],
})
export class PhysicalExplorationModule {}

================
File: src/medical-scheduling/modules/physical-exploration-data/physical-exploration/physical-exploration.service.ts
================
import { Injectable, HttpException } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { CreatePhysicalExplorationDto } from './dto/create-physical-exploration.dto';
import { UpdatePhysicalExplorationDto } from './dto/update-physical-exploration.dto';

@Injectable()
export class PhysicalExplorationService {
  constructor(private prisma: PrismaService) {}

  async createPhysicalExploration(
    data: CreatePhysicalExplorationDto | UpdatePhysicalExplorationDto,
  ): Promise<{ message: string }> {
    try {
      const existingExploration =
        await this.prisma.physical_exploration.findFirst({
          where: {
            medical_event_id: data.medical_event_id,
          },
        });

      if (existingExploration) {
        const hasChanges = Object.keys(data).some(
          (key) =>
            data[key] !== undefined && data[key] !== existingExploration[key],
        );

        if (!hasChanges) {
          return {
            message:
              'No changes detected. Existing physical exploration remains unchanged',
          };
        }

        await this.prisma.physical_exploration.update({
          where: {
            id: existingExploration.id,
          },
          data: {
            ...existingExploration,
            ...Object.fromEntries(
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              Object.entries(data).filter(([_, value]) => value !== undefined),
            ),
          },
        });
        return { message: 'Physical exploration updated successfully' };
      }

      const createData = data as CreatePhysicalExplorationDto;
      await this.prisma.physical_exploration.create({ data: createData });

      return { message: 'Physical exploration created successfully' };
    } catch (error) {
      throw new HttpException(
        'Error creating physical exploration',
        error.message,
      );
    }
  }
}

================
File: src/medical-scheduling/modules/pres_mod_history/dto/create-pres-history.dto.ts
================
import { IsBoolean, IsDate, IsOptional, IsString } from 'class-validator';

export class CreatePresHistoryDto {
  // Prescription - information
  @IsDate()
  @IsOptional()
  start_timestamp?: Date;

  @IsDate()
  @IsOptional()
  end_timestamp?: Date;

  @IsString()
  @IsOptional()
  description?: string;

  @IsBoolean()
  @IsOptional()
  active?: boolean;

  @IsString()
  @IsOptional()
  patient_id?: string;

  @IsString()
  @IsOptional()
  monodrug?: string;

  @IsString()
  @IsOptional()
  tenat_id?: string;

  // Prescription modification History

  @IsString()
  @IsOptional()
  prescription_id: string;

  @IsString()
  @IsOptional()
  physician_id: string;

  @IsDate()
  @IsOptional()
  mod_timestamp: Date;

  @IsOptional()
  medical_event_id?: string;

  // @IsOptional()
  // medical_order_id:string?

  @IsOptional()
  observations?: string;

  @IsString()
  dose: string;

  @IsString()
  dose_units: string;

  @IsString()
  frecuency: string;

  @IsString()
  duration: string;

  @IsString()
  duration_units: string;
}

================
File: src/medical-scheduling/modules/pres_mod_history/dto/update-pres_mod_history.dto.ts
================
import { PartialType } from '@nestjs/swagger';
import { CreatePresHistoryDto } from './create-pres-history.dto';

export class UpdatePresModHistoryDto extends PartialType(
  CreatePresHistoryDto,
) {}

================
File: src/medical-scheduling/modules/pres_mod_history/entities/pres_mod_history.entity.ts
================
export class PresModHistory {}

================
File: src/medical-scheduling/modules/pres_mod_history/pres_mod_history.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { PresModHistoryService } from './pres_mod_history.service';
import { CreatePresHistoryDto } from './dto/create-pres-history.dto';

@Controller('pres-mod-history')
export class PresModHistoryController {
  constructor(private readonly presModHistoryService: PresModHistoryService) {}

  @Post()
  create(@Body() createPresHistoryDto: CreatePresHistoryDto) {
    return this.presModHistoryService.create(createPresHistoryDto);
  }

  @Get('prescription/:id')
  findByPrescription_id(@Param('id') id: string) {
    return this.presModHistoryService.findByPrescription_id(id);
  }

  @Get('physician/:id')
  findByPhysician_id(@Param('id') id: string) {
    return this.presModHistoryService.findByPhysician_id(id);
  }

  @Get('medical_event/:id')
  findByMedical_event_id(@Param('id') id: string) {
    return this.presModHistoryService.findByMedical_event_id(id);
  }
}

================
File: src/medical-scheduling/modules/pres_mod_history/pres_mod_history.module.ts
================
import { Module } from '@nestjs/common';
import { PresModHistoryService } from './pres_mod_history.service';
import { PresModHistoryController } from './pres_mod_history.controller';
import { PrismaService } from 'src/prisma/prisma.service';

@Module({
  controllers: [PresModHistoryController],
  providers: [PresModHistoryService, PrismaService],
})
export class PresModHistoryModule {}

================
File: src/medical-scheduling/modules/pres_mod_history/pres_mod_history.service.ts
================
import { Injectable } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { CreatePresHistoryDto } from './dto/create-pres-history.dto';

@Injectable()
export class PresModHistoryService {
  constructor(private readonly prisma: PrismaService) {}

  // Implementar transactions
  async create(createPresHistoryDto: CreatePresHistoryDto) {
    try {
      await this.prisma.$transaction(async (op) => {
        let prescription = await op.prescription.findFirst({
          where: {
            AND: [
              { monodrug: createPresHistoryDto.monodrug },
              { active: true },
            ],
          },
        });
        if (!prescription) {
          prescription = await op.prescription.create({
            data: { monodrug: createPresHistoryDto.monodrug },
          });
        }

        delete createPresHistoryDto.start_timestamp;
        delete createPresHistoryDto.end_timestamp;
        delete createPresHistoryDto.description;
        delete createPresHistoryDto.active;
        delete createPresHistoryDto.patient_id;
        delete createPresHistoryDto.monodrug;
        delete createPresHistoryDto.tenat_id;

        createPresHistoryDto.prescription_id = prescription.id;

        const history = await op.pres_mod_history.create({
          data: { ...createPresHistoryDto },
        });
      });
      return { message: 'La historia ha sido creada' };
    } catch (error) {
      throw new Error(`No se ha podido generar la historia ${error.message}`);
    }
  }

  async findByPrescription_id(id: string) {
    try {
      const search = await this.prisma.pres_mod_history.findMany({
        where: { prescription_id: id },
      });
      return search;
    } catch (error) {
      throw new Error(
        `No se ha podido consultar por prescripción ${error.message}`,
      );
    }
  }

  async findByPhysician_id(id: string) {
    try {
      const search = await this.prisma.pres_mod_history.findMany({
        where: { physician_id: id },
      });
      return search;
    } catch (error) {
      throw new Error(`No se ha podido consultar por médico ${error.message}`);
    }
  }

  async findByMedical_event_id(id: string) {
    try {
      const search = await this.prisma.pres_mod_history.findMany({
        where: { medical_event_id: id },
      });
      return search;
    } catch (error) {
      throw new Error(
        `No se ha podido consultar por evento médico ${error.message}`,
      );
    }
  }
}

================
File: src/medical-scheduling/modules/prescription/dto/create-prescription.dto.ts
================
import { IsBoolean, IsDate, IsOptional, IsString } from 'class-validator';

export class CreatePrescriptionDto {
  @IsDate()
  @IsOptional()
  start_timestamp?: Date;

  @IsDate()
  @IsOptional()
  end_timestamp?: Date;

  @IsString()
  @IsOptional()
  description?: string;

  @IsBoolean()
  @IsOptional()
  active?: boolean;

  @IsString()
  @IsOptional()
  patient_id?: string;

  @IsString()
  monodrug: string;

  @IsString()
  @IsOptional()
  tenat_id?: string;
}

================
File: src/medical-scheduling/modules/prescription/dto/update-prescription.dto.ts
================
import { PartialType } from '@nestjs/swagger';
import { CreatePrescriptionDto } from './create-prescription.dto';

export class UpdatePrescriptionDto extends PartialType(CreatePrescriptionDto) {}

================
File: src/medical-scheduling/modules/prescription/entities/prescription.entity.ts
================
export class Prescription {}

================
File: src/medical-scheduling/modules/prescription/prescription.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { PrescriptionService } from './prescription.service';
import { CreatePrescriptionDto } from './dto/create-prescription.dto';
import { UpdatePrescriptionDto } from './dto/update-prescription.dto';

@Controller('prescription')
export class PrescriptionController {
  constructor(private readonly prescriptionService: PrescriptionService) {}

  @Post()
  create(@Body() createPrescriptionDto: CreatePrescriptionDto) {
    return this.prescriptionService.create(createPrescriptionDto);
  }

  @Get('patient/:id')
  findAllById(@Param('id') id: string) {
    this.prescriptionService.findAllById(id);
  }

  @Get()
  findAll() {
    return this.prescriptionService.findAll();
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.prescriptionService.remove(id);
  }

  // @IsOptional()
  // medical_order_id:string?
}

================
File: src/medical-scheduling/modules/prescription/prescription.module.ts
================
import { Module } from '@nestjs/common';
import { PrescriptionService } from './prescription.service';
import { PrescriptionController } from './prescription.controller';
import { PrismaService } from 'src/prisma/prisma.service';

@Module({
  controllers: [PrescriptionController],
  providers: [PrescriptionService, PrismaService],
})
export class PrescriptionModule {}

================
File: src/medical-scheduling/modules/prescription/prescription.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { CreatePrescriptionDto } from './dto/create-prescription.dto';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class PrescriptionService {
  constructor(private readonly prisma: PrismaService) {}
  async create(createPrescriptionDto: CreatePrescriptionDto) {
    try {
      const prescription = await this.prisma.prescription.create({
        data: { ...createPrescriptionDto },
      });
      return { message: 'La prescripción ha sido correctamente generada' };
    } catch (error) {
      throw new Error(
        `No se ha podido generar la prescripción ${error.message}`,
      );
    }
  }

  async findAll() {
    try {
      const prescriptions = await this.prisma.prescription.findMany({
        where: {
          active: true,
        },
      });
      return prescriptions;
    } catch (error) {
      throw new Error(
        `No se ha podido consultar las prescripciones ${error.message}`,
      );
    }
  }

  async findAllById(id: string) {
    try {
      const prescriptions = await this.prisma.prescription.findMany({
        where: {
          AND: [{ active: true }, { patient_id: id }],
        },
      });
      return prescriptions;
    } catch (error) {
      throw new Error(
        `No se ha podido consultar las prescripciones ${error.message}`,
      );
    }
  }

  async remove(id: string) {
    try {
      const prescription = await this.prisma.prescription.update({
        where: { id: id },
        data: { active: false },
      });
      if (!prescription)
        throw new NotFoundException('La prescripción no ha sido localizada');
      return { message: 'La prescripción ha sido eliminada' };
    } catch (error) {
      throw new Error(
        `No se ha podido eliminar la prescripción ${error.message}`,
      );
    }
  }
}

================
File: src/medical-scheduling/modules/vital-signs/dto/create-vital-sign.dto.ts
================
import {
  IsNotEmpty,
  IsUUID,
  IsNumber,
  IsOptional,
  IsArray,
  ValidateNested,
  ArrayNotEmpty,
} from 'class-validator';
import { Type } from 'class-transformer';

export class VitalSignDto {
  @IsNumber()
  @IsNotEmpty({ message: 'El ID del signo vital es obligatorio' })
  vital_sign_id: number;

  @IsNumber()
  @IsNotEmpty({ message: 'La medida es obligatoria' })
  measure: number;
}

export class CreateVitalSignDto {
  @IsUUID('4', { message: 'El ID del paciente debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del paciente es obligatorio' })
  patient_id: string;

  @IsUUID('4', { message: 'El ID del inquilino debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del inquilino es obligatorio' })
  tenant_id: string;

  @IsOptional()
  @IsUUID('4', { message: 'El ID del evento médico debe ser un UUID válido' })
  medical_event_id?: string;

  @IsOptional()
  @IsUUID('4', {
    message: 'El ID del evento de autoevaluación debe ser un UUID válido',
  })
  self_evaluation_event_id?: string;

  @IsArray()
  @ArrayNotEmpty({ message: 'Debe proporcionar al menos un signo vital' })
  @ValidateNested({ each: true })
  @Type(() => VitalSignDto)
  vital_signs: VitalSignDto[];
}

export class CreateMultipleVitalSignsDto {
  @IsArray()
  @ArrayNotEmpty({ message: 'Debe proporcionar al menos un signo vital' })
  @ValidateNested({ each: true })
  @Type(() => CreateVitalSignDto)
  vital_signs: CreateVitalSignDto[];
}

================
File: src/medical-scheduling/modules/vital-signs/dto/find-vital-signs.dto.ts
================
import { IsUUID, IsNotEmpty, IsOptional } from 'class-validator';

export class FindVitalSignsByPatientDto {
  @IsUUID('4', { message: 'El ID del paciente debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del paciente es obligatorio' })
  patient_id: string;

  @IsUUID('4', { message: 'El ID del inquilino debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del inquilino es obligatorio' })
  tenant_id: string;
}

export class FindVitalSignsByEventDto {
  @IsUUID('4', { message: 'El ID del evento médico debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del evento médico es obligatorio' })
  medical_event_id: string;

  @IsUUID('4', { message: 'El ID del inquilino debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del inquilino es obligatorio' })
  tenant_id: string;
}

export class FindVitalSignsBySelfEvaluationDto {
  @IsUUID('4', {
    message: 'El ID del evento de autoevaluación debe ser un UUID válido',
  })
  @IsNotEmpty({ message: 'El ID del evento de autoevaluación es obligatorio' })
  self_evaluation_event_id: string;

  @IsUUID('4', { message: 'El ID del inquilino debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del inquilino es obligatorio' })
  tenant_id: string;
}

================
File: src/medical-scheduling/modules/vital-signs/dto/update-vital-sign.dto.ts
================
import { PartialType } from '@nestjs/mapped-types';
import { CreateVitalSignDto } from './create-vital-sign.dto';

export class UpdateVitalSignDto extends PartialType(CreateVitalSignDto) {}

================
File: src/medical-scheduling/modules/vital-signs/vital-signs.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Request,
  UseGuards,
  BadRequestException,
} from '@nestjs/common';
import { VitalSignsService } from './vital-signs.service';
import { CreateVitalSignDto } from './dto/create-vital-sign.dto';
import { FindVitalSignsByPatientDto } from './dto/find-vital-signs.dto';
import { RequirePermission } from '../../../auth/decorators/require-permission.decorator';
import { Permission } from '../../../auth/permissions/permission.enum';
import { PermissionGuard } from '../../../auth/guards/permission.guard';
import { TenantAccessGuard } from '../../../auth/guards/tenant-access.guard';

@Controller('vital-signs')
@UseGuards(TenantAccessGuard, PermissionGuard)
export class VitalSignsController {
  constructor(private readonly vitalSignsService: VitalSignsService) {}

  @Post()
  @RequirePermission(Permission.VIEW_PATIENT_DETAILS)
  async create(@Body() createVitalSignDto: CreateVitalSignDto, @Request() req) {
    // Asegurarse de que el tenant_id en el DTO coincide con el del request
    if (createVitalSignDto.tenant_id !== req.tenant?.id) {
      throw new BadRequestException(
        'El tenant_id no coincide con el tenant del usuario',
      );
    }

    return this.vitalSignsService.create(createVitalSignDto);
  }

  @Get('patient/:patientId')
  @RequirePermission(Permission.VIEW_PATIENT_DETAILS)
  async findAllByPatient(
    @Param('patientId') patientId: string,
    @Request() req,
  ) {
    const findDto: FindVitalSignsByPatientDto = {
      patient_id: patientId,
      tenant_id: req.tenant?.id,
    };

    return this.vitalSignsService.findAllByPatient(findDto);
  }

  @Delete(':id')
  @RequirePermission(Permission.EDIT_PATIENT_INFO)
  async remove(@Param('id') id: string, @Request() req) {
    return this.vitalSignsService.remove(id, req.user?.id, req.tenant?.id);
  }
}

================
File: src/medical-scheduling/modules/vital-signs/vital-signs.module.ts
================
import { Module } from '@nestjs/common';
import { VitalSignsService } from './vital-signs.service';
import { VitalSignsController } from './vital-signs.controller';
import { PrismaService } from '../../../prisma/prisma.service';
import { GuardAuthModule } from '../../../auth/guard-auth.module';

@Module({
  imports: [GuardAuthModule],
  controllers: [VitalSignsController],
  providers: [VitalSignsService, PrismaService],
  exports: [VitalSignsService],
})
export class VitalSignsModule {}

================
File: src/medical-scheduling/modules/vital-signs/vital-signs.service.ts
================
import {
  Injectable,
  BadRequestException,
  NotFoundException,
  ForbiddenException,
} from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { CreateVitalSignDto, VitalSignDto } from './dto/create-vital-sign.dto';
import { FindVitalSignsByPatientDto } from './dto/find-vital-signs.dto';

@Injectable()
export class VitalSignsService {
  constructor(private prisma: PrismaService) {}

  /**
   * Crea o actualiza un conjunto de signos vitales
   * Valida que no existan signos vitales duplicados para un mismo evento
   * @param createVitalSignDto Datos para crear o actualizar signos vitales
   */
  async create(createVitalSignDto: CreateVitalSignDto) {
    const {
      patient_id,
      tenant_id,
      medical_event_id,
      self_evaluation_event_id,
      vital_signs,
    } = createVitalSignDto;

    // Validar que se proporciona solo un tipo de evento (medical_event o self_evaluation_event)
    if (medical_event_id && self_evaluation_event_id) {
      throw new BadRequestException(
        'No puede proporcionar ID de evento médico y de autoevaluación simultáneamente',
      );
    }

    if (!medical_event_id && !self_evaluation_event_id) {
      throw new BadRequestException(
        'Debe proporcionar un ID de evento médico o de autoevaluación',
      );
    }

    try {
      // Verificar que el paciente existe
      const patient = await this.prisma.user.findUnique({
        where: { id: patient_id },
        include: { patient: true },
      });

      if (!patient || !patient.patient) {
        throw new NotFoundException('Paciente no encontrado');
      }

      // Si es un evento médico, verificar que el paciente y el tenant coincidan
      if (medical_event_id) {
        const medicalEvent = await this.prisma.medical_event.findUnique({
          where: { id: medical_event_id },
          include: {
            patient: true,
            physician: {
              include: {
                user: true,
              },
            },
          },
        });

        if (!medicalEvent) {
          throw new NotFoundException('Evento médico no encontrado');
        }

        // Verificar que el paciente del evento médico coincide con el paciente proporcionado
        if (medicalEvent.patient_id !== patient.patient.id) {
          throw new BadRequestException(
            'El paciente no coincide con el evento médico',
          );
        }

        // Verificar que el tenant del evento médico coincide con el tenant proporcionado
        if (medicalEvent.tenant_id !== tenant_id) {
          throw new BadRequestException(
            'El tenant no coincide con el evento médico',
          );
        }
      }

      // Si es un evento de autoevaluación, verificar que el paciente y el tenant coincidan
      if (self_evaluation_event_id) {
        const selfEvaluationEvent =
          await this.prisma.self_evaluation_event.findUnique({
            where: { id: self_evaluation_event_id },
          });

        if (!selfEvaluationEvent) {
          throw new NotFoundException('Evento de autoevaluación no encontrado');
        }

        // Verificar que el paciente del evento de autoevaluación coincide con el paciente proporcionado
        if (selfEvaluationEvent.patient_id !== patient_id) {
          throw new BadRequestException(
            'El paciente no coincide con el evento de autoevaluación',
          );
        }

        // Verificar que el tenant del evento de autoevaluación coincide con el tenant proporcionado
        if (selfEvaluationEvent.tenant_id !== tenant_id) {
          throw new BadRequestException(
            'El tenant no coincide con el evento de autoevaluación',
          );
        }
      }

      // Obtener los signos vitales existentes para este evento
      const existingVitalSigns = await this.prisma.vital_signs.findMany({
        where: {
          ...(medical_event_id && { medical_event_id }),
          ...(self_evaluation_event_id && { self_evaluation_event_id }),
          deleted: false,
        },
      });

      // Identificar qué signos vitales deben crearse, actualizarse o eliminarse
      const vitalSignsToCreate: VitalSignDto[] = [];
      const vitalSignsToUpdate: { id: string; measure: number }[] = [];
      const vitalSignsToDelete: string[] = [];

      // ID de signos vitales proporcionados en la solicitud
      const providedVitalSignIds = vital_signs.map((vs) => vs.vital_sign_id);

      // Marcar signos vitales para actualización o eliminación
      for (const existingVS of existingVitalSigns) {
        const matchingVS = vital_signs.find(
          (vs) => vs.vital_sign_id === existingVS.vital_sign_id,
        );

        if (matchingVS) {
          // Si la medida ha cambiado, actualizar
          if (matchingVS.measure !== existingVS.measure) {
            vitalSignsToUpdate.push({
              id: existingVS.id,
              measure: matchingVS.measure,
            });
          }
        } else {
          // Si el signo vital ya no está en la solicitud, eliminarlo (soft delete)
          vitalSignsToDelete.push(existingVS.id);
        }
      }

      // Identificar signos vitales nuevos
      for (const vs of vital_signs) {
        const exists = existingVitalSigns.some(
          (existingVS) => existingVS.vital_sign_id === vs.vital_sign_id,
        );

        if (!exists) {
          vitalSignsToCreate.push(vs);
        }
      }

      // Verificar que no hay signos vitales duplicados
      const uniqueVitalSignIds = new Set(providedVitalSignIds);
      if (uniqueVitalSignIds.size !== providedVitalSignIds.length) {
        throw new BadRequestException(
          'No se permiten signos vitales duplicados para un mismo evento',
        );
      }

      // Ejecutar las operaciones en una transacción
      return this.prisma.$transaction(async (tx) => {
        // Crear nuevos signos vitales
        const createdVitalSigns = [];
        for (const vs of vitalSignsToCreate) {
          const newVitalSign = await tx.vital_signs.create({
            data: {
              patient_id,
              tenant_id,
              ...(medical_event_id && { medical_event_id }),
              ...(self_evaluation_event_id && { self_evaluation_event_id }),
              vital_sign_id: vs.vital_sign_id,
              measure: vs.measure,
            },
          });
          createdVitalSigns.push(newVitalSign);
        }

        // Actualizar signos vitales existentes
        const updatedVitalSigns = [];
        for (const vs of vitalSignsToUpdate) {
          const updatedVitalSign = await tx.vital_signs.update({
            where: { id: vs.id },
            data: { measure: vs.measure, updated_at: new Date() },
          });
          updatedVitalSigns.push(updatedVitalSign);
        }

        // Eliminar signos vitales que ya no se necesitan (soft delete)
        const deletedVitalSigns = [];
        for (const id of vitalSignsToDelete) {
          const deletedVitalSign = await tx.vital_signs.update({
            where: { id },
            data: { deleted: true, deleted_at: new Date() },
          });
          deletedVitalSigns.push(deletedVitalSign);
        }

        // Obtener todos los signos vitales actualizados
        const allVitalSigns = await tx.vital_signs.findMany({
          where: {
            ...(medical_event_id && { medical_event_id }),
            ...(self_evaluation_event_id && { self_evaluation_event_id }),
            deleted: false,
          },
          include: {
            vital_sign: true,
          },
        });

        return {
          created: createdVitalSigns.length,
          updated: updatedVitalSigns.length,
          deleted: deletedVitalSigns.length,
          vital_signs: allVitalSigns,
        };
      });
    } catch (error) {
      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException ||
        error instanceof ForbiddenException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Error al crear/actualizar signos vitales: ${error.message}`,
      );
    }
  }

  /**
   * Encuentra todos los signos vitales agrupados por evento
   * @param findVitalSignsDto Datos para buscar los signos vitales
   */
  async findAllByPatient(findVitalSignsDto: FindVitalSignsByPatientDto) {
    try {
      const { patient_id, tenant_id } = findVitalSignsDto;

      // Verificar que el paciente existe
      const patient = await this.prisma.user.findUnique({
        where: { id: patient_id },
        include: { patient: true },
      });

      if (!patient || !patient.patient) {
        throw new NotFoundException('Paciente no encontrado');
      }

      // Obtener todos los eventos médicos del paciente
      const medicalEvents = await this.prisma.medical_event.findMany({
        where: {
          patient_id: patient.patient.id,
          tenant_id,
          deleted: false,
        },
        select: {
          id: true,
          created_at: true,
          updated_at: true,
          physician: {
            select: {
              user: {
                select: {
                  id: true,
                  name: true,
                  last_name: true,
                },
              },
            },
          },
          vital_signs: {
            where: { deleted: false },
            include: {
              vital_sign: true,
            },
          },
        },
      });

      // Obtener todos los eventos de autoevaluación del paciente
      const selfEvaluationEvents =
        await this.prisma.self_evaluation_event.findMany({
          where: {
            patient_id,
            tenant_id,
          },
          select: {
            id: true,
            created_at: true,
            updated_at: true,
            vital_signs: {
              where: { deleted: false },
              include: {
                vital_sign: true,
              },
            },
          },
        });

      return {
        medical_events: medicalEvents,
        self_evaluation_events: selfEvaluationEvents,
      };
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException(
        `Error al obtener signos vitales: ${error.message}`,
      );
    }
  }

  /**
   * Elimina un signo vital (soft delete)
   * Solo puede ser eliminado por el médico relacionado con el evento o un superadmin
   * @param id ID del signo vital
   * @param userId ID del usuario que realiza la eliminación
   * @param tenantId ID del tenant
   */
  async remove(id: string, userId: string, tenantId: string) {
    try {
      // Obtener el signo vital
      const vitalSign = await this.prisma.vital_signs.findUnique({
        where: { id },
        include: {
          medical_event: {
            include: {
              physician: true,
            },
          },
        },
      });

      if (!vitalSign) {
        throw new NotFoundException('Signo vital no encontrado');
      }

      // Verificar que el tenant coincide
      if (vitalSign.tenant_id !== tenantId) {
        throw new ForbiddenException(
          'No tiene permisos para eliminar este signo vital',
        );
      }

      // Verificar que el usuario es el médico relacionado con el evento médico o un superadmin
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new NotFoundException('Usuario no encontrado');
      }

      const isSuperAdmin = user.is_superadmin;
      const isPhysician =
        vitalSign.medical_event &&
        vitalSign.medical_event.physician &&
        vitalSign.medical_event.physician.user_id === userId;

      if (!isSuperAdmin && !isPhysician) {
        throw new ForbiddenException(
          'No tiene permisos para eliminar este signo vital',
        );
      }

      // Eliminar el signo vital (soft delete)
      return this.prisma.vital_signs.update({
        where: { id },
        data: {
          deleted: true,
          deleted_at: new Date(),
        },
      });
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof ForbiddenException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Error al eliminar signo vital: ${error.message}`,
      );
    }
  }
}

================
File: src/mobile-functions/mobile-functions.module.ts
================
import { Module } from '@nestjs/common';
import { SelfEvaluationEventModule } from './self-evaluation-event/self-evaluation-event.module';

@Module({
  imports: [SelfEvaluationEventModule],
})
export class MobileFunctionsModule {}

================
File: src/mobile-functions/self-evaluation-event/dto/create-self-evaluation-event.dto.ts
================
import {
  IsString,
  IsNotEmpty,
  IsUUID,
  IsArray,
  ValidateNested,
  ArrayNotEmpty,
} from 'class-validator';
import { Type } from 'class-transformer';
import { VitalSignDto } from '../../../medical-scheduling/modules/vital-signs/dto/create-vital-sign.dto';

export class CreateSelfEvaluationEventDto {
  @IsUUID('4', { message: 'El ID del paciente debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del paciente es obligatorio' })
  patient_id: string;

  @IsUUID('4', { message: 'El ID del evento médico debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del evento médico es obligatorio' })
  medical_event_id: string;

  @IsUUID('4', { message: 'El ID del inquilino debe ser un UUID válido' })
  @IsNotEmpty({ message: 'El ID del inquilino es obligatorio' })
  tenant_id: string;

  @IsArray()
  @ArrayNotEmpty({ message: 'Debe proporcionar al menos un signo vital' })
  @ValidateNested({ each: true })
  @Type(() => VitalSignDto)
  vital_signs: VitalSignDto[];
}

================
File: src/mobile-functions/self-evaluation-event/self-evaluation-event.controller.ts
================
import {
  Controller,
  Post,
  Body,
  Request,
  UseGuards,
  BadRequestException,
} from '@nestjs/common';
import { SelfEvaluationEventService } from './self-evaluation-event.service';
import { CreateSelfEvaluationEventDto } from './dto/create-self-evaluation-event.dto';
import { RequirePermission } from '../../auth/decorators/require-permission.decorator';
import { Permission } from '../../auth/permissions/permission.enum';
import { PermissionGuard } from '../../auth/guards/permission.guard';
import { TenantAccessGuard } from '../../auth/guards/tenant-access.guard';

@Controller('mobile/self-evaluation-event')
@UseGuards(TenantAccessGuard, PermissionGuard)
export class SelfEvaluationEventController {
  constructor(
    private readonly selfEvaluationEventService: SelfEvaluationEventService,
  ) {}

  @Post()
  @RequirePermission(Permission.VIEW_PATIENT_DETAILS)
  async create(
    @Body() createSelfEvaluationEventDto: CreateSelfEvaluationEventDto,
    @Request() req,
  ) {
    // Verificar que el tenant_id en el DTO coincide con el tenant del request
    if (createSelfEvaluationEventDto.tenant_id !== req.tenant?.id) {
      throw new BadRequestException(
        'El tenant_id no coincide con el tenant del usuario',
      );
    }

    // Verificar que el patient_id en el DTO coincide con el usuario autenticado o tiene permisos
    if (
      createSelfEvaluationEventDto.patient_id !== req.user?.id &&
      !req.user?.is_superadmin &&
      req.user?.role !== 'physician'
    ) {
      throw new BadRequestException('No tiene permisos para crear este evento');
    }

    return this.selfEvaluationEventService.create(createSelfEvaluationEventDto);
  }
}

================
File: src/mobile-functions/self-evaluation-event/self-evaluation-event.module.ts
================
import { Module } from '@nestjs/common';
import { SelfEvaluationEventService } from './self-evaluation-event.service';
import { SelfEvaluationEventController } from './self-evaluation-event.controller';
import { PrismaService } from '../../prisma/prisma.service';
import { GuardAuthModule } from '../../auth/guard-auth.module';
import { VitalSignsModule } from '../../medical-scheduling/modules/vital-signs/vital-signs.module';

@Module({
  imports: [GuardAuthModule, VitalSignsModule],
  controllers: [SelfEvaluationEventController],
  providers: [SelfEvaluationEventService, PrismaService],
})
export class SelfEvaluationEventModule {}

================
File: src/mobile-functions/self-evaluation-event/self-evaluation-event.service.ts
================
import {
  Injectable,
  BadRequestException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateSelfEvaluationEventDto } from './dto/create-self-evaluation-event.dto';
import { VitalSignsService } from '../../medical-scheduling/modules/vital-signs/vital-signs.service';

@Injectable()
export class SelfEvaluationEventService {
  constructor(
    private prisma: PrismaService,
    private vitalSignsService: VitalSignsService,
  ) {}

  /**
   * Crea un evento de autoevaluación con sus signos vitales asociados
   * @param createSelfEvaluationEventDto Datos para crear el evento
   */
  async create(createSelfEvaluationEventDto: CreateSelfEvaluationEventDto) {
    const { patient_id, medical_event_id, tenant_id, vital_signs } =
      createSelfEvaluationEventDto;

    try {
      // Verificar que el paciente existe
      const patient = await this.prisma.user.findUnique({
        where: { id: patient_id },
        include: { patient: true },
      });

      if (!patient || !patient.patient) {
        throw new NotFoundException('Paciente no encontrado');
      }

      // Verificar que el evento médico existe y pertenece al paciente
      const medicalEvent = await this.prisma.medical_event.findUnique({
        where: { id: medical_event_id },
        include: {
          patient: true,
        },
      });

      if (!medicalEvent) {
        throw new NotFoundException('Evento médico no encontrado');
      }

      if (medicalEvent.patient_id !== patient.patient.id) {
        throw new BadRequestException(
          'El paciente no coincide con el evento médico',
        );
      }

      if (medicalEvent.tenant_id !== tenant_id) {
        throw new BadRequestException(
          'El tenant no coincide con el evento médico',
        );
      }

      return this.prisma.$transaction(async (tx) => {
        const selfEvaluationEvent = await tx.self_evaluation_event.create({
          data: {
            patient_id,
            medical_event_id,
            tenant_id,
          },
        });

        // Crear los signos vitales asociados
        if (vital_signs && vital_signs.length > 0) {
          await this.vitalSignsService.create({
            patient_id,
            tenant_id,
            self_evaluation_event_id: selfEvaluationEvent.id,
            vital_signs,
          });
        }

        // Obtener el evento completo con los signos vitales
        return await tx.self_evaluation_event.findUnique({
          where: { id: selfEvaluationEvent.id },
          include: {
            vital_signs: {
              include: {
                vital_sign: true,
              },
            },
          },
        });
      });
    } catch (error) {
      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Error al crear evento de autoevaluación: ${error.message}`,
      );
    }
  }
}

================
File: src/prisma/prisma.module.ts
================
import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}

================
File: src/prisma/prisma.service.ts
================
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
import { tenantPrismaMiddleware } from 'src/utils/middlewares/tenantPrismaMiddleware';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  async onModuleInit() {
    await this.$connect();

    this.$use(tenantPrismaMiddleware());

    console.log('Prisma middleware registered');
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}

================
File: src/services/email/email.module.ts
================
import { Global, Module } from '@nestjs/common';
import { EmailService } from './email.service';
@Global()
@Module({
  providers: [EmailService],
  exports: [EmailService],
  controllers: [],
})
export class EmailModule {}

================
File: src/services/email/email.service.ts
================
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { google } from 'googleapis';

@Injectable()
export class EmailService {
  private oauth2Client;
  private gmail;
  constructor(private configService: ConfigService) {
    const MAIL_CLIENT_ID = this.configService.get<string>('MAIL_CLIENT_ID');
    const MAIL_CLIENT_SECRET =
      this.configService.get<string>('MAIL_CLIENT_SECRET');
    const MAIL_REFRESH_TOKEN =
      this.configService.get<string>('MAIL_REFRESH_TOKEN');

    this.oauth2Client = new google.auth.OAuth2(
      MAIL_CLIENT_ID,
      MAIL_CLIENT_SECRET,
    );

    this.oauth2Client.setCredentials({
      refresh_token: MAIL_REFRESH_TOKEN,
    });

    this.gmail = google.gmail({ version: 'v1', auth: this.oauth2Client });
  }

  private encodeBase64URL(str: string) {
    return Buffer.from(str, 'utf8')
      .toString('base64')
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=+$/, '');
  }

  private encodeMIMEHeader(text: string) {
    return `=?UTF-8?B?${Buffer.from(text, 'utf8').toString('base64')}?=`;
  }

  async sendMail(destination: string, mailBody: string, mailSubject: string) {
    const encodedSubject = this.encodeMIMEHeader(mailSubject);

    const message = [
      `To: ${destination}`,
      `From: ${this.configService.get('SENDER_MAIL_ADDRESS')}`,
      'Content-Type: text/html; charset=utf-8',
      `Subject: ${encodedSubject}`,
      '',
      mailBody,
    ].join('\n');

    const encodedMessage = this.encodeBase64URL(message);

    try {
      const response = await this.gmail.users.messages.send({
        userId: 'me',
        resource: {
          raw: encodedMessage,
        },
      });

      return response.data;
    } catch {
      throw new Error('Error al enviar el correo');
    }
  }
}

================
File: src/services/email/templates/credentialsHtml.ts
================
export const sendCredentialsHtml = (
  email: string,
  password: string,
): string => {
  return `<!DOCTYPE html>
  <html>
    <head>
      <meta
        name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=2,shrink-to-fit=no" />
      <title>Credenciales de acceso</title>
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
        body {
          font-family: "Poppins", sans-serif;
          background-color: #fafafc;
          margin: 0;
          padding: 0;
          width: 600px;
        }
        .container {
          width: 100%;
          padding: 20px 0;
          text-align: center;
          background-color: #fafafc;
        }
        .email-content {
          width: 90%;
          padding: 0 15px;
          max-width: 600px;
          margin: 0 auto;
          background-color: #fff;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .logo-container {
          padding: 20px 0;
        }
        .logo-container img {
          display: block;
          margin: 0 auto;
          width: 180px;
        }
        .content {
          padding: 45px 0 20px 0;
          text-align: center;
          color: #808080;
          font-size: 16px;
          width: 100%;
          margin: 0 auto;
        }
        .content h1 {
          font-size: 32px;
          color: #487ffa;
          font-weight: 500;
          margin-bottom: 30px;
        }
        .credentials {
          font-size: 18px;
          background-color: #f4f4f4;
          padding: 15px;
          border-radius: 5px;
          display: inline-block;
          margin-top: 10px;
        }
        .footer {
          padding: 40px 0;
          font-size: 14px;
          color: #808080;
          width: 60%;
          margin: 0 auto;
          text-align: center;
        }
        @media only screen and (max-width: 600px) {
          body {
            width: 90%;
          }
          .email-content {
            width: 100% !important;
            box-shadow: none;
          }
          .logo-container img {
            width: 150px;
          }
          .content {
            padding: 30px 10px 10px 10px;
            font-size: 18px;
            width: 100%;
          }
          .content h1 {
            font-size: 28px;
          }
          .footer {
            padding: 20px 0;
            font-size: 12px;
            width: 100%;
          }
        }
      </style>
    </head>
    <body>
      <table class="container" cellpadding="0" cellspacing="0" width="100%">
        <tr>
          <td align="center" class="logo-container">
            <img
              src="https://res.cloudinary.com/dya1ekkd5/image/upload/v1721930541/oidzxqlccwuewq2daqoa.png"
              alt="Logo" />
          </td>
        </tr>
        <tr>
          <td align="center">
            <table
              class="email-content"
              cellpadding="0"
              cellspacing="0"
              width="100%">
              <tr>
                <td class="content">
                  <h1>Bienvenido a nuestra plataforma</h1>
                  <p>Estas son tus credenciales de acceso:</p>
                  <p class="credentials"><strong>Email:</strong> ${email}</p>
                  <p class="credentials"><strong>Contraseña:</strong> ${password}</p>
                  <p>Te recomendamos cambiar tu contraseña después de iniciar sesión.</p>
                </td>
              </tr>
              <tr>
                <td class="footer">
                  <p>
                    Si no solicitaste estas credenciales, por favor ignora este correo.
                  </p>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </body>
  </html>
    `;
};

================
File: src/services/email/templates/recoverPasswordHtml.ts
================
export const recoverPasswordHtml = (link: string): string => {
  return `<!DOCTYPE html>
<html>
  <head>
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=2,shrink-to-fit=no" />
    <title>Recuperar contraseña</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Poppins", sans-serif;
        background-color: #fafafc;
        margin: 0;
        padding: 0;
        width: 600px;
      }
      .container {
        width: 100%;
        padding: 20px 0;
        text-align: center;
        background-color: #fafafc;
      }
      .email-content {
        width: 90%;
        padding: 0 15px;
        max-width: 600px;
        margin: 0 auto;
        background-color: #fff;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .logo-container {
        padding: 20px 0;
      }
      .logo-container img {
        display: block;
        margin: 0 auto;
        width: 180px;
      }
      .content {
        padding: 45px 0 20px 0;
        text-align: center;
        color: #808080;
        font-size: 16px;
        width: 100%;
        margin: 0 auto;
      }
      .content h1 {
        font-size: 32px;
        color: #487ffa;
        font-weight: 500;
        margin-bottom: 30px;
      }
      .content h2 {
        font-size: 42px;
        color: #487ffa;
        font-weight: 500;
      }
      .content p {
        margin-bottom: 20px;
      }
      .button {
        text-align: center;
        color: #808080;
        font-size: 16px;
        width: 60%;
        margin: 0 auto;
      }
      .footer {
        padding: 40px 0;
        font-size: 14px;
        color: #808080;
        width: 60%;
        margin: 0 auto;
        text-align: center;
      }
      @media only screen and (max-width: 600px) {
        body {
          width: 90%;
        }
        .email-content {
          width: 100% !important;
          box-shadow: none;
        }
        .logo-container img {
          width: 150px;
        }
        .content {
          padding: 30px 10px 10px 10px;
          font-size: 18px;
          width: 100%;
        }
        .content h1 {
          font-size: 28px;
        }
        .button {
          padding-top: 10px;
          padding-bottom: 25px;
        }
        .footer {
          padding: 20px 0;
          font-size: 12px;
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <table class="container" cellpadding="0" cellspacing="0" width="100%">
      <tr>
        <td align="center" class="logo-container">
          <img
            src="https://res.cloudinary.com/dya1ekkd5/image/upload/v1721930541/oidzxqlccwuewq2daqoa.png"
            alt="Logo" />
        </td>
      </tr>
      <tr>
        <td align="center">
          <table
            class="email-content"
            cellpadding="0"
            cellspacing="0"
            width="100%">
            <tr>
              <td class="content">
                <h1>Tu link para cambiar contraseña</h1>
                <p>
                  Entra al siguiente
                  <a style="color: #808080; font-weight: 700" href="${link}"
                    >link</a
                  >
                  o presiona el botón para poder cambiar tu contraseña.
                </p>
              </td>
            </tr>
            <tr>
              <td class="button">
                <a
                  href="${link}"
                  style="
                    padding: 15px 20px;
                    border-radius: 10px;
                    text-decoration: none;
                    background: #487ffa;
                    color: white;
                    font-weight: 700;
                  ">
                  Cambiar contraseña
                </a>
              </td>
            </tr>
            <tr>
              <td class="footer">
                <p>
                  Si no solicitaste cambiar tu contraseña, puedes ignorar este
                  correo. Solo las personas con acceso a tu email cambiar tu contraseña.
                </p>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </body>
</html>


`;
};

================
File: src/services/email/templates/welcomeEmailHtml.ts
================
const welcomeEmailHtml = (name: string): string => {
  return `<!DOCTYPE html>
  <html>
    <head>
      <title>Confirmar email</title>
      <meta
        name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=2,shrink-to-fit=no" />
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
        body {
          font-family: "Poppins", sans-serif;
          background-color: #fafafc;
          margin: 0;
          padding: 0;
          width: 600px;
        }
        .container {
          width: 100%;
          padding: 20px 0;
          text-align: center;
          background-color: #fafafc;
        }
        .email-content {
          width: 90%;
          padding: 0 15px;
          max-width: 600px;
          margin: 0 auto;
          background-color: #fff;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .logo-container {
          padding: 20px 0;
        }
        .logo-container img {
          display: block;
          margin: 0 auto;
          width: 180px;
        }
        .content {
          padding: 35px 0 10px 0;
          text-align: center;
          color: #808080;
          font-size: 16px;
          width: 100%;
          margin: 0 auto;
        }
        .content h1 {
          font-size: 32px;
          color: #487ffa;
          font-weight: 500;
          margin-bottom: 10px;
        }
        .content h2 {
          font-size: 42px;
          color: #487ffa;
          font-weight: 500;
        }
        .content p {
          margin-bottom: 20px;
        }
        .body {
          text-align: center;
          color: #808080;
          font-size: 20px;
          width: 60%;
        }
        .body p {
          margin-bottom: 20px;
        }
        .footer {
          padding: 10px 0 20px 0;
          font-size: 20px;
          color: #808080;
          width: 60%;
          margin: 0 auto;
          text-align: center;
        }
        @media only screen and (max-width: 600px) {
          body {
            width: 90%;
          }
          .email-content {
            width: 100% !important;
            box-shadow: none;
          }
          .logo-container img {
            width: 150px;
          }
          .content {
            padding: 20px 10px 10px 10px;
            font-size: 18px;
            width: 100%;
          }
          .content h1 {
            font-size: 28px;
          }
          .body {
            padding-top: 10px;
            padding-bottom: 25px;
          }
          .footer {
            padding: 20px 0;
            font-size: 20px;
            width: 100%;
          }
        }
      </style>
    </head>
    <body>
      <table class="container" cellpadding="0" cellspacing="0" width="100%">
        <tr>
          <td align="center" class="logo-container">
            <img
              src="https://res.cloudinary.com/dya1ekkd5/image/upload/v1721930541/oidzxqlccwuewq2daqoa.png"
              alt="Logo" />
          </td>
        </tr>
        <tr>
          <td align="center">
            <table
              class="email-content"
              cellpadding="0"
              cellspacing="0"
              width="100%">
              <tr>
                <td class="content">
                  <h1>¡Bienvenido a Segimed!</h1>
                </td>
              </tr>
              <tr>
                <td class="body">
                  <p>Hola ${name},</p>
                  <p>
                    ¡Nos alegra mucho darte la bienvenida a Segimed! Estamos
                    encantados de que te unas a nosotros.
                  </p>
                  <p>
                    En Segimed, nos esforzamos por ofrecerte la mejor experiencia
                    posible. Si tenes alguna pregunta o necesitas ayuda, no dudes
                    en ponerte en contacto con nuestro equipo de soporte. Estamos
                    para ayudarte en cada paso.
                  </p>
                </td>
              </tr>
              <tr>
                <td class="footer">
                  <p>-El equipo de Segimed.</p>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </body>
  </html>`;
};

export default welcomeEmailHtml;

================
File: src/services/twilio/twilio.module.ts
================
import { Global, Module } from '@nestjs/common';
import { TwilioService } from './twilio.service';

@Global()
@Module({
  providers: [TwilioService],
  exports: [TwilioService],
})
export class TwilioModule {}

================
File: src/services/twilio/twilio.service.ts
================
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Twilio } from 'twilio';

@Injectable()
export class TwilioService {
  private twilioClient: Twilio;

  constructor(private configService: ConfigService) {
    this.twilioClient = new Twilio(
      this.configService.get<string>('TWILIO_ACCOUNT_SID'),
      this.configService.get<string>('TWILIO_AUTH_TOKEN'),
    );
  }

  async sendOtp(phoneNumber: string, otp: string): Promise<void> {
    const message = `Tu código de verificación es: ${otp}`;

    await this.twilioClient.messages.create({
      body: message,
      from: `whatsapp:${this.configService.get<string>('TWILIO_WHATSAPP_FROM')}`,
      to: `whatsapp:${phoneNumber}`,
    });
  }

  generateOtp(): string {
    return Math.floor(100000 + Math.random() * 900000).toString();
  }
}

================
File: src/utils/auth.helper.ts
================
import * as bcrypt from 'bcrypt';
import * as jwt from 'jsonwebtoken';

export class AuthHelper {
  static async hashPassword(
    password: string,
    saltRounds: number,
  ): Promise<string> {
    const salt = await bcrypt.genSalt(saltRounds);
    return bcrypt.hash(password, salt);
  }

  static async comparePasswords(
    plainPassword: string,
    hashedPassword: string,
  ): Promise<boolean> {
    return bcrypt.compare(plainPassword, hashedPassword);
  }

  static generateToken(payload: object, expiresIn: string = '7d'): string {
    const secret = process.env.JWT_SECRET || 'defaultSecret';
    return jwt.sign(payload, secret, { expiresIn });
  }

  static verifyToken(token: string): string | jwt.JwtPayload {
    const secret = process.env.JWT_SECRET || 'defaultSecret';
    return jwt.verify(token, secret);
  }
}

================
File: src/utils/cloudinary.ts
================
import { v2 as cloudinary } from 'cloudinary';
import { config as dontenvcongif } from 'dotenv';

dontenvcongif({ path: '.env.development' });

export const CloudinaryConfig = {
  provide: 'CLOUDINARY',
  useFactory: () => {
    return cloudinary.config({
      cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
      api_key: process.env.CLOUDINARY_API_KEY,
      api_secret: process.env.CLOUDINARY_API_SECRET,
    });
  },
};

================
File: src/utils/file_upload/file_upload.controller.ts
================
import {
  Controller,
  Post,
  UploadedFile,
  UseInterceptors,
  ParseFilePipe,
  MaxFileSizeValidator,
  FileTypeValidator,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { FileUploadService } from './file_upload.service';
import { ApiTags } from '@nestjs/swagger';
import { Multer } from 'multer';

@Controller('files')
@ApiTags('Upload File')
export class FileUploadController {
  constructor(private readonly fileUploadService: FileUploadService) {}

  @Post('upload')
  @UseInterceptors(FileInterceptor('file'))
  async uploadFile(
    @UploadedFile(
      new ParseFilePipe({
        validators: [
          new MaxFileSizeValidator({
            maxSize: 10 * 1024 * 1024, // 10MB para PDF, 5MB para imágenes
            message:
              'File exceeds the maximum size of 10MB for PDFs or 5MB for images',
          }),
          new FileTypeValidator({
            fileType: /^(image\/(jpg|jpeg|png|webp|svg)|application\/pdf)$/i,
          }),
        ],
      }),
    )
    file: Multer.File,
  ) {
    try {
      const result = await this.fileUploadService.uploadFile(file);
      return result; // Retorna la URL y el tipo
    } catch (error) {
      throw new Error('File upload failed: ' + error.message); // Maneja errores aquí
    }
  }
}

================
File: src/utils/file_upload/file_upload.module.ts
================
import { Module } from '@nestjs/common';
import { FileUploadController } from './file_upload.controller';
import { FileUploadService } from './file_upload.service';
import { CloudinaryConfig } from '../cloudinary';
import { FileUploadRepository } from './file_upload.repository';

@Module({
  imports: [],
  controllers: [FileUploadController],
  providers: [FileUploadService, CloudinaryConfig, FileUploadRepository],
})
export class FileUploadModule {}

================
File: src/utils/file_upload/file_upload.repository.ts
================
import { Injectable } from '@nestjs/common';
import { v2 as cloudinary } from 'cloudinary';
import { Multer } from 'multer';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class FileUploadRepository {
  constructor(private configService: ConfigService) {
    cloudinary.config({
      cloud_name: this.configService.get('CLOUDINARY_CLOUD_NAME'),
      api_key: this.configService.get('CLOUDINARY_API_KEY'),
      api_secret: this.configService.get('CLOUDINARY_API_SECRET'),
    });
  }

  async uploadFile(file: Multer.File): Promise<any> {
    try {
      // Convertir el buffer a base64
      const base64String = `data:${file.mimetype};base64,${file.buffer.toString('base64')}`;
      console.log(base64String);
      console.log(file);

      // Determinar el tipo de recurso
      let resourceType = 'auto';
      if (file.mimetype.startsWith('image/')) {
        resourceType = 'image';
      } else if (file.mimetype === 'application/pdf') {
        resourceType = 'auto';
      }

      // Subir a Cloudinary
      const uploadResult = await cloudinary.uploader.upload(base64String, {
        resource_type: resourceType as 'auto' | 'image' | 'raw',
        folder: resourceType === 'image' ? 'images' : 'documents',
      });

      return uploadResult;
    } catch (error) {
      console.error('Error al subir el archivo a Cloudinary:', error);
      throw new Error('Error al subir el archivo a Cloudinary');
    }
  }
}

================
File: src/utils/file_upload/file_upload.service.ts
================
import { Injectable } from '@nestjs/common';
import { FileUploadRepository } from './file_upload.repository';
import { Multer } from 'multer';

@Injectable()
export class FileUploadService {
  constructor(private readonly fileUploadRepository: FileUploadRepository) {}

  async uploadFile(file: Multer.File): Promise<{ url: string; type: string }> {
    const result = await this.fileUploadRepository.uploadFile(file);

    return {
      url: result.secure_url,
      type: file.mimetype.startsWith('image/') ? 'image' : 'pdf',
    };
  }
}

================
File: src/utils/middlewares/tenantMiddleware.ts
================
import {
  Injectable,
  NestMiddleware,
  UnauthorizedException,
} from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { PrismaService } from 'src/prisma/prisma.service';
import { AuthHelper } from '../auth.helper';

@Injectable()
export class TenantMiddleware implements NestMiddleware {
  constructor(private readonly prisma: PrismaService) {}

  async use(req: Request, res: Response, next: NextFunction) {
    try {
      const authorization = req.headers['authorization'];
      if (!authorization) {
        throw new UnauthorizedException('Authorization header missing');
      }

      const token = authorization.replace('Bearer ', '');
      let payload: any;

      try {
        payload = AuthHelper.verifyToken(token);
      } catch (error) {
        throw new UnauthorizedException(`Invalid token: ${error.message}`);
      }

      const tenant_id = payload?.tenant_id;
      if (!tenant_id) {
        throw new UnauthorizedException('Tenant ID not found in token');
      }

      const tenant = await this.prisma.tenant.findUnique({
        where: {
          id: tenant_id,
        },
      });
      if (!tenant) {
        throw new UnauthorizedException('Invalid tenant');
      }

      // Guardar en el contexto global
      global.tenant_id = tenant_id;

      req['tenant_id'] = tenant_id;
      req['tenant'] = tenant;

      next();
    } catch (error) {
      console.log(error);
      next(error);
    }
  }
}

================
File: src/utils/middlewares/tenantPrismaMiddleware.ts
================
import { Prisma } from '@prisma/client';

export function tenantPrismaMiddleware() {
  return async (params: Prisma.MiddlewareParams, next: Prisma.Middleware) => {
    const tenantRules: Record<
      string,
      { actions: string[]; requireTenantId: boolean }
    > = {
      user: { actions: ['findMany'], requireTenantId: true },
      patient: {
        actions: ['findMany', 'update', 'create'],
        requireTenantId: true,
      },
      appointment: {
        actions: ['findMany', 'findFirst'],
        requireTenantId: true,
      },
      medical_event: {
        actions: ['findMany', 'create', 'update'],
        requireTenantId: true,
      },
      transaction: { actions: ['findMany', 'create'], requireTenantId: true },
      organization: { actions: ['update'], requireTenantId: true },
      patient_tenant: { actions: ['create', 'delete'], requireTenantId: true },
    };

    const modelRules = tenantRules[params.model];

    if (!modelRules || !modelRules.actions.includes(params.action)) {
      return next(params, params.args);
    }

    try {
      const tenant_id = params.args?.tenant_id || global.tenant_id;

      if (modelRules.requireTenantId && !tenant_id) {
        throw new Error(
          `Tenant verification failed: missing tenant_id for ${params.model} in ${params.action} action.`,
        );
      }

      if (['create'].includes(params.action)) {
        params.args.data = {
          ...params.args.data,
          tenant_id: tenant_id,
        };
      }

      if (['findMany', 'findFirst', 'findUnique'].includes(params.action)) {
        params.args.where = {
          ...params.args.where,
          tenant_id: tenant_id,
        };
      }

      return next(params, params.args);
    } catch (error) {
      console.error('Error in tenantPrismaMiddleware:', error);
      throw new Error(`Middleware error: ${error.message}`);
    }
  };
}

================
File: src/utils/pagination.helper.ts
================
export interface PaginationParams {
  page?: number | string;
  pageSize?: number | string;
  orderBy?: string;
  orderDirection?: 'asc' | 'desc';
}

export function parsePaginationAndSorting(params: PaginationParams) {
  const page = params.page && Number(params.page) > 0 ? Number(params.page) : 1;
  const pageSize =
    params.pageSize && Number(params.pageSize) > 0
      ? Number(params.pageSize)
      : 10;
  const skip = (page - 1) * pageSize;
  const take = pageSize;

  const orderBy = params.orderBy || 'id';
  const orderDirection = params.orderDirection || 'asc';

  return { skip, take, orderBy, orderDirection };
}

================
File: test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES6",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}



================================================================
End of Codebase
================================================================
